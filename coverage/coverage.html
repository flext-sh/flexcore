
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>commands: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/flext/flexcore/application/commands/command_bus.go (45.0%)</option>
				
				<option value="file1">github.com/flext/flexcore/application/commands/pipeline_commands.go (0.0%)</option>
				
				<option value="file2">github.com/flext/flexcore/application/queries/pipeline_queries.go (0.0%)</option>
				
				<option value="file3">github.com/flext/flexcore/application/queries/query_bus.go (0.0%)</option>
				
				<option value="file4">github.com/flext/flexcore/cmd/flexcore/main.go (0.0%)</option>
				
				<option value="file5">github.com/flext/flexcore/core/deprecation.go (0.0%)</option>
				
				<option value="file6">github.com/flext/flexcore/domain/base.go (88.9%)</option>
				
				<option value="file7">github.com/flext/flexcore/domain/entities/pipeline.go (76.7%)</option>
				
				<option value="file8">github.com/flext/flexcore/domain/entities/pipeline_events.go (100.0%)</option>
				
				<option value="file9">github.com/flext/flexcore/domain/entities/plugin.go (0.0%)</option>
				
				<option value="file10">github.com/flext/flexcore/examples/plugin/main.go (0.0%)</option>
				
				<option value="file11">github.com/flext/flexcore/infrastructure/config/manager.go (0.0%)</option>
				
				<option value="file12">github.com/flext/flexcore/infrastructure/di/advanced_container.go (0.0%)</option>
				
				<option value="file13">github.com/flext/flexcore/infrastructure/di/container.go (0.0%)</option>
				
				<option value="file14">github.com/flext/flexcore/infrastructure/handlers/chain.go (0.0%)</option>
				
				<option value="file15">github.com/flext/flexcore/infrastructure/observability/metrics.go (0.0%)</option>
				
				<option value="file16">github.com/flext/flexcore/infrastructure/observability/monitor.go (0.0%)</option>
				
				<option value="file17">github.com/flext/flexcore/infrastructure/observability/tracing.go (0.0%)</option>
				
				<option value="file18">github.com/flext/flexcore/infrastructure/persistence/repository.go (0.0%)</option>
				
				<option value="file19">github.com/flext/flexcore/internal/domain/core.go (83.9%)</option>
				
				<option value="file20">github.com/flext/flexcore/pkg/adapter/base_adapter.go (0.0%)</option>
				
				<option value="file21">github.com/flext/flexcore/pkg/adapter/builder.go (0.0%)</option>
				
				<option value="file22">github.com/flext/flexcore/pkg/patterns/option.go (0.0%)</option>
				
				<option value="file23">github.com/flext/flexcore/pkg/patterns/query_builder.go (0.0%)</option>
				
				<option value="file24">github.com/flext/flexcore/pkg/patterns/railway.go (0.0%)</option>
				
				<option value="file25">github.com/flext/flexcore/shared/errors/errors.go (0.0%)</option>
				
				<option value="file26">github.com/flext/flexcore/shared/patterns/options.go (0.0%)</option>
				
				<option value="file27">github.com/flext/flexcore/shared/result/result.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package commands provides CQRS command handling infrastructure
package commands

import (
        "context"
        "reflect"
        "sync"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Command represents a command in the CQRS pattern
type Command interface {
        CommandType() string
}

// CommandHandler represents a handler for a specific command type
type CommandHandler[T Command] interface {
        Handle(ctx context.Context, command T) result.Result[interface{}]
}

// CommandBus coordinates command execution
type CommandBus interface {
        RegisterHandler(command Command, handler interface{}) error
        Execute(ctx context.Context, command Command) result.Result[interface{}]
        ExecuteAsync(ctx context.Context, command Command) result.Result[chan result.Result[interface{}]]
}

// InMemoryCommandBus provides an in-memory implementation of CommandBus
type InMemoryCommandBus struct {
        mu       sync.RWMutex
        handlers map[string]interface{}
}

// NewInMemoryCommandBus creates a new in-memory command bus
func NewInMemoryCommandBus() *InMemoryCommandBus <span class="cov7" title="6">{
        return &amp;InMemoryCommandBus{
                handlers: make(map[string]interface{}),
        }
}</span>

// NewCommandBus creates a new command bus (returns interface)
func NewCommandBus() CommandBus <span class="cov6" title="5">{
        return NewInMemoryCommandBus()
}</span>

// RegisterHandler registers a command handler
func (bus *InMemoryCommandBus) RegisterHandler(command Command, handler interface{}) error <span class="cov6" title="5">{
        if command == nil </span><span class="cov0" title="0">{
                return errors.ValidationError("command cannot be nil")
        }</span>

        <span class="cov6" title="5">if handler == nil </span><span class="cov0" title="0">{
                return errors.ValidationError("handler cannot be nil")
        }</span>

        // Validate handler implements CommandHandler interface
        <span class="cov6" title="5">handlerType := reflect.TypeOf(handler)
        if !bus.isValidHandler(handlerType) </span><span class="cov0" title="0">{
                return errors.ValidationError("handler must implement CommandHandler interface")
        }</span>

        <span class="cov6" title="5">commandType := command.CommandType()
        
        bus.mu.Lock()
        defer bus.mu.Unlock()

        if _, exists := bus.handlers[commandType]; exists </span><span class="cov0" title="0">{
                return errors.AlreadyExistsError("handler for command type " + commandType)
        }</span>

        <span class="cov6" title="5">bus.handlers[commandType] = handler
        return nil</span>
}

// Execute executes a command synchronously
func (bus *InMemoryCommandBus) Execute(ctx context.Context, command Command) result.Result[interface{}] <span class="cov7" title="7">{
        if command == nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.ValidationError("command cannot be nil"))
        }</span>

        <span class="cov7" title="7">bus.mu.RLock()
        handler, exists := bus.handlers[command.CommandType()]
        bus.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return result.Failure[interface{}](errors.NotFoundError("handler for command type " + command.CommandType()))
        }</span>

        <span class="cov7" title="6">return bus.invokeHandler(ctx, handler, command)</span>
}

// ExecuteAsync executes a command asynchronously
func (bus *InMemoryCommandBus) ExecuteAsync(ctx context.Context, command Command) result.Result[chan result.Result[interface{}]] <span class="cov1" title="1">{
        resultChan := make(chan result.Result[interface{}], 1)

        go func() </span><span class="cov1" title="1">{
                defer close(resultChan)
                result := bus.Execute(ctx, command)
                resultChan &lt;- result
        }</span>()

        <span class="cov1" title="1">return result.Success(resultChan)</span>
}

// isValidHandler checks if a type implements the CommandHandler interface
func (bus *InMemoryCommandBus) isValidHandler(handlerType reflect.Type) bool <span class="cov6" title="5">{
        // Check if it has a Handle method with correct signature
        method, exists := handlerType.MethodByName("Handle")
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check method signature: Handle(ctx context.Context, command T) result.Result[interface{}]
        <span class="cov6" title="5">methodType := method.Type
        if methodType.NumIn() != 3 || methodType.NumOut() != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check context parameter
        <span class="cov6" title="5">contextType := reflect.TypeOf((*context.Context)(nil)).Elem()
        if !methodType.In(1).Implements(contextType) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check command parameter implements Command interface
        <span class="cov6" title="5">commandType := reflect.TypeOf((*Command)(nil)).Elem()
        if !methodType.In(2).Implements(commandType) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="5">return true</span>
}

// invokeHandler invokes a command handler using reflection
func (bus *InMemoryCommandBus) invokeHandler(ctx context.Context, handler interface{}, command Command) result.Result[interface{}] <span class="cov7" title="6">{
        handlerValue := reflect.ValueOf(handler)
        handlerType := reflect.TypeOf(handler)

        method, exists := handlerType.MethodByName("Handle")
        if !exists </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.InternalError("handler does not have Handle method"))
        }</span>

        // Prepare arguments
        <span class="cov7" title="6">args := []reflect.Value{
                handlerValue,
                reflect.ValueOf(ctx),
                reflect.ValueOf(command),
        }

        // Call the handler method
        results := method.Func.Call(args)
        if len(results) != 1 </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.InternalError("handler returned unexpected number of values"))
        }</span>

        // Extract the result
        <span class="cov7" title="6">resultValue := results[0].Interface()
        if cmdResult, ok := resultValue.(result.Result[interface{}]); ok </span><span class="cov7" title="6">{
                return cmdResult
        }</span>

        <span class="cov0" title="0">return result.Failure[interface{}](errors.InternalError("handler returned unexpected result type"))</span>
}

// GetRegisteredCommands returns all registered command types
func (bus *InMemoryCommandBus) GetRegisteredCommands() []string <span class="cov0" title="0">{
        bus.mu.RLock()
        defer bus.mu.RUnlock()

        commands := make([]string, 0, len(bus.handlers))
        for commandType := range bus.handlers </span><span class="cov0" title="0">{
                commands = append(commands, commandType)
        }</span>
        <span class="cov0" title="0">return commands</span>
}

// BaseCommand provides a base implementation for commands
type BaseCommand struct {
        commandType string
}

// NewBaseCommand creates a new base command
func NewBaseCommand(commandType string) BaseCommand <span class="cov7" title="7">{
        return BaseCommand{commandType: commandType}
}</span>

// CommandType returns the command type
func (c BaseCommand) CommandType() string <span class="cov10" title="13">{
        return c.commandType
}</span>

// Decorator represents a command decorator
type Decorator interface {
        Decorate(ctx context.Context, command Command, next func(ctx context.Context, command Command) result.Result[interface{}]) result.Result[interface{}]
}

// DecoratedCommandBus wraps a command bus with decorators
type DecoratedCommandBus struct {
        inner      CommandBus
        decorators []Decorator
}

// NewDecoratedCommandBus creates a new decorated command bus
func NewDecoratedCommandBus(inner CommandBus, decorators ...Decorator) *DecoratedCommandBus <span class="cov0" title="0">{
        return &amp;DecoratedCommandBus{
                inner:      inner,
                decorators: decorators,
        }
}</span>

// RegisterHandler registers a command handler
func (bus *DecoratedCommandBus) RegisterHandler(command Command, handler interface{}) error <span class="cov0" title="0">{
        return bus.inner.RegisterHandler(command, handler)
}</span>

// Execute executes a command with decorators applied
func (bus *DecoratedCommandBus) Execute(ctx context.Context, command Command) result.Result[interface{}] <span class="cov0" title="0">{
        next := func(ctx context.Context, cmd Command) result.Result[interface{}] </span><span class="cov0" title="0">{
                return bus.inner.Execute(ctx, cmd)
        }</span>

        // Apply decorators in reverse order
        <span class="cov0" title="0">for i := len(bus.decorators) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                decorator := bus.decorators[i]
                currentNext := next
                next = func(ctx context.Context, cmd Command) result.Result[interface{}] </span><span class="cov0" title="0">{
                        return decorator.Decorate(ctx, cmd, currentNext)
                }</span>
        }

        <span class="cov0" title="0">return next(ctx, command)</span>
}

// ExecuteAsync executes a command asynchronously with decorators applied
func (bus *DecoratedCommandBus) ExecuteAsync(ctx context.Context, command Command) result.Result[chan result.Result[interface{}]] <span class="cov0" title="0">{
        resultChan := make(chan result.Result[interface{}], 1)

        go func() </span><span class="cov0" title="0">{
                defer close(resultChan)
                result := bus.Execute(ctx, command)
                resultChan &lt;- result
        }</span>()

        <span class="cov0" title="0">return result.Success(resultChan)</span>
}

// LoggingDecorator logs command execution
type LoggingDecorator struct {
        logger Logger
}

// Logger interface for logging
type Logger interface {
        Info(msg string, fields ...interface{})
        Error(msg string, err error, fields ...interface{})
}

// NewLoggingDecorator creates a new logging decorator
func NewLoggingDecorator(logger Logger) *LoggingDecorator <span class="cov0" title="0">{
        return &amp;LoggingDecorator{logger: logger}
}</span>

// Decorate decorates command execution with logging
func (d *LoggingDecorator) Decorate(ctx context.Context, command Command, next func(ctx context.Context, command Command) result.Result[interface{}]) result.Result[interface{}] <span class="cov0" title="0">{
        d.logger.Info("Executing command", "type", command.CommandType())
        
        result := next(ctx, command)
        
        if result.IsSuccess() </span><span class="cov0" title="0">{
                d.logger.Info("Command executed successfully", "type", command.CommandType())
        }</span> else<span class="cov0" title="0"> {
                d.logger.Error("Command execution failed", result.Error(), "type", command.CommandType())
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// ValidationDecorator validates commands before execution
type ValidationDecorator struct {
        validators map[string]CommandValidator
}

// CommandValidator validates commands
type CommandValidator interface {
        Validate(command Command) error
}

// NewValidationDecorator creates a new validation decorator
func NewValidationDecorator() *ValidationDecorator <span class="cov0" title="0">{
        return &amp;ValidationDecorator{
                validators: make(map[string]CommandValidator),
        }
}</span>

// RegisterValidator registers a validator for a command type
func (d *ValidationDecorator) RegisterValidator(commandType string, validator CommandValidator) <span class="cov0" title="0">{
        d.validators[commandType] = validator
}</span>

// Decorate decorates command execution with validation
func (d *ValidationDecorator) Decorate(ctx context.Context, command Command, next func(ctx context.Context, command Command) result.Result[interface{}]) result.Result[interface{}] <span class="cov0" title="0">{
        if validator, exists := d.validators[command.CommandType()]; exists </span><span class="cov0" title="0">{
                if err := validator.Validate(command); err != nil </span><span class="cov0" title="0">{
                        return result.Failure[interface{}](errors.Wrap(err, "command validation failed"))
                }</span>
        }
        
        <span class="cov0" title="0">return next(ctx, command)</span>
}

// MetricsDecorator collects metrics for command execution
type MetricsDecorator struct {
        metricsCollector MetricsCollector
}

// MetricsCollector collects execution metrics
type MetricsCollector interface {
        RecordCommandExecution(commandType string, duration int64, success bool)
}

// NewMetricsDecorator creates a new metrics decorator
func NewMetricsDecorator(collector MetricsCollector) *MetricsDecorator <span class="cov0" title="0">{
        return &amp;MetricsDecorator{metricsCollector: collector}
}</span>

// Decorate decorates command execution with metrics collection
func (d *MetricsDecorator) Decorate(ctx context.Context, command Command, next func(ctx context.Context, command Command) result.Result[interface{}]) result.Result[interface{}] <span class="cov0" title="0">{
        // start := result.Try(func() int64 { return 0 }).Value() // Simplified for example
        
        result := next(ctx, command)
        
        duration := int64(0) // Calculate actual duration
        d.metricsCollector.RecordCommandExecution(command.CommandType(), duration, result.IsSuccess())
        
        return result
}</span>

// CommandBusBuilder helps build command bus configurations
type CommandBusBuilder struct {
        decorators []Decorator
}

// NewCommandBusBuilder creates a new command bus builder
func NewCommandBusBuilder() *CommandBusBuilder <span class="cov1" title="1">{
        return &amp;CommandBusBuilder{
                decorators: make([]Decorator, 0),
        }
}</span>

// WithLogging adds logging decorator
func (b *CommandBusBuilder) WithLogging(logger Logger) *CommandBusBuilder <span class="cov0" title="0">{
        b.decorators = append(b.decorators, NewLoggingDecorator(logger))
        return b
}</span>

// WithValidation adds validation decorator
func (b *CommandBusBuilder) WithValidation() *CommandBusBuilder <span class="cov0" title="0">{
        b.decorators = append(b.decorators, NewValidationDecorator())
        return b
}</span>

// WithMetrics adds metrics decorator
func (b *CommandBusBuilder) WithMetrics(collector MetricsCollector) *CommandBusBuilder <span class="cov0" title="0">{
        b.decorators = append(b.decorators, NewMetricsDecorator(collector))
        return b
}</span>

// WithDecorator adds a custom decorator
func (b *CommandBusBuilder) WithDecorator(decorator Decorator) *CommandBusBuilder <span class="cov0" title="0">{
        b.decorators = append(b.decorators, decorator)
        return b
}</span>

// Build creates the command bus
func (b *CommandBusBuilder) Build() CommandBus <span class="cov1" title="1">{
        inner := NewInMemoryCommandBus()
        
        if len(b.decorators) == 0 </span><span class="cov1" title="1">{
                return inner
        }</span>
        
        <span class="cov0" title="0">return NewDecoratedCommandBus(inner, b.decorators...)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package commands provides pipeline-specific commands
package commands

import (
        "context"
        "time"

        "github.com/flext/flexcore/domain/entities"
        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// CreatePipelineCommand represents a command to create a new pipeline
type CreatePipelineCommand struct {
        BaseCommand
        Name        string
        Description string
        Owner       string
        Tags        []string
}

// NewCreatePipelineCommand creates a new create pipeline command
func NewCreatePipelineCommand(name, description, owner string, tags []string) CreatePipelineCommand <span class="cov0" title="0">{
        return CreatePipelineCommand{
                BaseCommand: NewBaseCommand("CreatePipeline"),
                Name:        name,
                Description: description,
                Owner:       owner,
                Tags:        tags,
        }
}</span>

// CreatePipelineCommandHandler handles pipeline creation commands
type CreatePipelineCommandHandler struct {
        repository PipelineRepository
        eventBus   EventBus
}

// PipelineRepository represents a repository for pipelines
type PipelineRepository interface {
        Save(ctx context.Context, pipeline *entities.Pipeline) error
        FindByID(ctx context.Context, id entities.PipelineID) (*entities.Pipeline, error)
        FindByName(ctx context.Context, name string) (*entities.Pipeline, error)
        Delete(ctx context.Context, id entities.PipelineID) error
        List(ctx context.Context, limit, offset int) ([]*entities.Pipeline, error)
}

// EventBus represents an event bus for publishing domain events
type EventBus interface {
        Publish(ctx context.Context, event interface{}) error
}

// NewCreatePipelineCommandHandler creates a new create pipeline command handler
func NewCreatePipelineCommandHandler(repository PipelineRepository, eventBus EventBus) *CreatePipelineCommandHandler <span class="cov0" title="0">{
        return &amp;CreatePipelineCommandHandler{
                repository: repository,
                eventBus:   eventBus,
        }
}</span>

// Handle handles the create pipeline command
func (h *CreatePipelineCommandHandler) Handle(ctx context.Context, command CreatePipelineCommand) result.Result[interface{}] <span class="cov0" title="0">{
        // Check if pipeline with same name already exists
        if existingPipeline, _ := h.repository.FindByName(ctx, command.Name); existingPipeline != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.AlreadyExistsError("pipeline with name " + command.Name))
        }</span>

        // Create new pipeline
        <span class="cov0" title="0">pipelineResult := entities.NewPipeline(command.Name, command.Description, command.Owner)
        if pipelineResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](pipelineResult.Error())
        }</span>

        <span class="cov0" title="0">pipeline := pipelineResult.Value()

        // Add tags
        for _, tag := range command.Tags </span><span class="cov0" title="0">{
                pipeline.AddTag(tag)
        }</span>

        // Save pipeline
        <span class="cov0" title="0">if err := h.repository.Save(ctx, pipeline); err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to save pipeline"))
        }</span>

        // Publish domain events
        <span class="cov0" title="0">for _, event := range pipeline.DomainEvents() </span><span class="cov0" title="0">{
                if err := h.eventBus.Publish(ctx, event); err != nil </span>{<span class="cov0" title="0">
                        // Log error but don't fail the command
                }</span>
        }

        <span class="cov0" title="0">pipeline.ClearEvents()

        return result.Success[interface{}](pipeline)</span>
}

// AddPipelineStepCommand represents a command to add a step to a pipeline
type AddPipelineStepCommand struct {
        BaseCommand
        PipelineID   entities.PipelineID
        StepName     string
        StepType     string
        Config       map[string]interface{}
        DependsOn    []string
        MaxRetries   int
        Timeout      time.Duration
}

// NewAddPipelineStepCommand creates a new add pipeline step command
func NewAddPipelineStepCommand(pipelineID entities.PipelineID, stepName, stepType string) AddPipelineStepCommand <span class="cov0" title="0">{
        return AddPipelineStepCommand{
                BaseCommand: NewBaseCommand("AddPipelineStep"),
                PipelineID:  pipelineID,
                StepName:    stepName,
                StepType:    stepType,
                Config:      make(map[string]interface{}),
                DependsOn:   make([]string, 0),
                MaxRetries:  3,
                Timeout:     time.Minute * 30,
        }
}</span>

// AddPipelineStepCommandHandler handles add pipeline step commands
type AddPipelineStepCommandHandler struct {
        repository PipelineRepository
        eventBus   EventBus
}

// NewAddPipelineStepCommandHandler creates a new add pipeline step command handler
func NewAddPipelineStepCommandHandler(repository PipelineRepository, eventBus EventBus) *AddPipelineStepCommandHandler <span class="cov0" title="0">{
        return &amp;AddPipelineStepCommandHandler{
                repository: repository,
                eventBus:   eventBus,
        }
}</span>

// Handle handles the add pipeline step command
func (h *AddPipelineStepCommandHandler) Handle(ctx context.Context, command AddPipelineStepCommand) result.Result[interface{}] <span class="cov0" title="0">{
        // Find pipeline
        pipeline, err := h.repository.FindByID(ctx, command.PipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        // Create step
        <span class="cov0" title="0">step := entities.NewPipelineStep(command.StepName, command.StepType)
        step.Config = command.Config
        step.DependsOn = command.DependsOn
        step.MaxRetries = command.MaxRetries
        step.Timeout = command.Timeout

        // Add step to pipeline
        addResult := pipeline.AddStep(step)
        if addResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](addResult.Error())
        }</span>

        // Save pipeline
        <span class="cov0" title="0">if err := h.repository.Save(ctx, pipeline); err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to save pipeline"))
        }</span>

        // Publish domain events
        <span class="cov0" title="0">for _, event := range pipeline.DomainEvents() </span><span class="cov0" title="0">{
                if err := h.eventBus.Publish(ctx, event); err != nil </span>{<span class="cov0" title="0">
                        // Log error but don't fail the command
                }</span>
        }

        <span class="cov0" title="0">pipeline.ClearEvents()

        return result.Success[interface{}](step)</span>
}

// ExecutePipelineCommand represents a command to execute a pipeline
type ExecutePipelineCommand struct {
        BaseCommand
        PipelineID entities.PipelineID
        Parameters map[string]interface{}
}

// NewExecutePipelineCommand creates a new execute pipeline command
func NewExecutePipelineCommand(pipelineID entities.PipelineID, parameters map[string]interface{}) ExecutePipelineCommand <span class="cov0" title="0">{
        return ExecutePipelineCommand{
                BaseCommand: NewBaseCommand("ExecutePipeline"),
                PipelineID:  pipelineID,
                Parameters:  parameters,
        }
}</span>

// ExecutePipelineCommandHandler handles pipeline execution commands
type ExecutePipelineCommandHandler struct {
        repository     PipelineRepository
        eventBus       EventBus
        workflowEngine WorkflowEngine
}

// WorkflowEngine represents a workflow execution engine
type WorkflowEngine interface {
        StartWorkflow(ctx context.Context, workflowName string, input interface{}) (string, error)
}

// NewExecutePipelineCommandHandler creates a new execute pipeline command handler
func NewExecutePipelineCommandHandler(repository PipelineRepository, eventBus EventBus, workflowEngine WorkflowEngine) *ExecutePipelineCommandHandler <span class="cov0" title="0">{
        return &amp;ExecutePipelineCommandHandler{
                repository:     repository,
                eventBus:       eventBus,
                workflowEngine: workflowEngine,
        }
}</span>

// Handle handles the execute pipeline command
func (h *ExecutePipelineCommandHandler) Handle(ctx context.Context, command ExecutePipelineCommand) result.Result[interface{}] <span class="cov0" title="0">{
        // Find pipeline
        pipeline, err := h.repository.FindByID(ctx, command.PipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        // Check if pipeline can be executed
        <span class="cov0" title="0">if !pipeline.CanExecute() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.ValidationError("pipeline cannot be executed"))
        }</span>

        // Start pipeline execution
        <span class="cov0" title="0">startResult := pipeline.Start()
        if startResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](startResult.Error())
        }</span>

        // Save pipeline state
        <span class="cov0" title="0">if err := h.repository.Save(ctx, pipeline); err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to save pipeline"))
        }</span>

        // Start workflow execution
        <span class="cov0" title="0">workflowInput := map[string]interface{}{
                "pipelineID": pipeline.ID.String(),
                "parameters": command.Parameters,
        }

        workflowID, err := h.workflowEngine.StartWorkflow(ctx, "pipeline-execution", workflowInput)
        if err != nil </span><span class="cov0" title="0">{
                // Mark pipeline as failed
                pipeline.Fail("failed to start workflow: " + err.Error())
                h.repository.Save(ctx, pipeline)
                return result.Failure[interface{}](errors.Wrap(err, "failed to start workflow"))
        }</span>

        // Publish domain events
        <span class="cov0" title="0">for _, event := range pipeline.DomainEvents() </span><span class="cov0" title="0">{
                if err := h.eventBus.Publish(ctx, event); err != nil </span>{<span class="cov0" title="0">
                        // Log error but don't fail the command
                }</span>
        }

        <span class="cov0" title="0">pipeline.ClearEvents()

        executionResult := map[string]interface{}{
                "pipelineID": pipeline.ID.String(),
                "workflowID": workflowID,
                "status":     pipeline.Status.String(),
        }

        return result.Success[interface{}](executionResult)</span>
}

// ActivatePipelineCommand represents a command to activate a pipeline
type ActivatePipelineCommand struct {
        BaseCommand
        PipelineID entities.PipelineID
}

// NewActivatePipelineCommand creates a new activate pipeline command
func NewActivatePipelineCommand(pipelineID entities.PipelineID) ActivatePipelineCommand <span class="cov0" title="0">{
        return ActivatePipelineCommand{
                BaseCommand: NewBaseCommand("ActivatePipeline"),
                PipelineID:  pipelineID,
        }
}</span>

// ActivatePipelineCommandHandler handles pipeline activation commands
type ActivatePipelineCommandHandler struct {
        repository PipelineRepository
        eventBus   EventBus
}

// NewActivatePipelineCommandHandler creates a new activate pipeline command handler
func NewActivatePipelineCommandHandler(repository PipelineRepository, eventBus EventBus) *ActivatePipelineCommandHandler <span class="cov0" title="0">{
        return &amp;ActivatePipelineCommandHandler{
                repository: repository,
                eventBus:   eventBus,
        }
}</span>

// Handle handles the activate pipeline command
func (h *ActivatePipelineCommandHandler) Handle(ctx context.Context, command ActivatePipelineCommand) result.Result[interface{}] <span class="cov0" title="0">{
        // Find pipeline
        pipeline, err := h.repository.FindByID(ctx, command.PipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        // Activate pipeline
        <span class="cov0" title="0">activateResult := pipeline.Activate()
        if activateResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](activateResult.Error())
        }</span>

        // Save pipeline
        <span class="cov0" title="0">if err := h.repository.Save(ctx, pipeline); err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to save pipeline"))
        }</span>

        // Publish domain events
        <span class="cov0" title="0">for _, event := range pipeline.DomainEvents() </span><span class="cov0" title="0">{
                if err := h.eventBus.Publish(ctx, event); err != nil </span>{<span class="cov0" title="0">
                        // Log error but don't fail the command
                }</span>
        }

        <span class="cov0" title="0">pipeline.ClearEvents()

        return result.Success[interface{}](pipeline)</span>
}

// SetPipelineScheduleCommand represents a command to set a pipeline schedule
type SetPipelineScheduleCommand struct {
        BaseCommand
        PipelineID     entities.PipelineID
        CronExpression string
        Timezone       string
}

// NewSetPipelineScheduleCommand creates a new set pipeline schedule command
func NewSetPipelineScheduleCommand(pipelineID entities.PipelineID, cronExpression, timezone string) SetPipelineScheduleCommand <span class="cov0" title="0">{
        return SetPipelineScheduleCommand{
                BaseCommand:    NewBaseCommand("SetPipelineSchedule"),
                PipelineID:     pipelineID,
                CronExpression: cronExpression,
                Timezone:       timezone,
        }
}</span>

// SetPipelineScheduleCommandHandler handles set pipeline schedule commands
type SetPipelineScheduleCommandHandler struct {
        repository PipelineRepository
        eventBus   EventBus
}

// NewSetPipelineScheduleCommandHandler creates a new set pipeline schedule command handler
func NewSetPipelineScheduleCommandHandler(repository PipelineRepository, eventBus EventBus) *SetPipelineScheduleCommandHandler <span class="cov0" title="0">{
        return &amp;SetPipelineScheduleCommandHandler{
                repository: repository,
                eventBus:   eventBus,
        }
}</span>

// Handle handles the set pipeline schedule command
func (h *SetPipelineScheduleCommandHandler) Handle(ctx context.Context, command SetPipelineScheduleCommand) result.Result[interface{}] <span class="cov0" title="0">{
        // Find pipeline
        pipeline, err := h.repository.FindByID(ctx, command.PipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        // Set schedule
        <span class="cov0" title="0">scheduleResult := pipeline.SetSchedule(command.CronExpression, command.Timezone)
        if scheduleResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[interface{}](scheduleResult.Error())
        }</span>

        // Save pipeline
        <span class="cov0" title="0">if err := h.repository.Save(ctx, pipeline); err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.Wrap(err, "failed to save pipeline"))
        }</span>

        // Publish domain events
        <span class="cov0" title="0">for _, event := range pipeline.DomainEvents() </span><span class="cov0" title="0">{
                if err := h.eventBus.Publish(ctx, event); err != nil </span>{<span class="cov0" title="0">
                        // Log error but don't fail the command
                }</span>
        }

        <span class="cov0" title="0">pipeline.ClearEvents()

        return result.Success[interface{}](pipeline.Schedule)</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Package queries provides pipeline-specific queries
package queries

import (
        "context"
        "strings"
        "time"

        "github.com/flext/flexcore/domain/entities"
        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// PipelineRepository represents a repository for pipelines (read operations)
type PipelineRepository interface {
        FindByID(ctx context.Context, id entities.PipelineID) (*entities.Pipeline, error)
        FindByName(ctx context.Context, name string) (*entities.Pipeline, error)
        List(ctx context.Context, limit, offset int) ([]*entities.Pipeline, error)
        Count(ctx context.Context) (int, error)
        FindByOwner(ctx context.Context, owner string, limit, offset int) ([]*entities.Pipeline, error)
        FindByTag(ctx context.Context, tag string, limit, offset int) ([]*entities.Pipeline, error)
        FindByStatus(ctx context.Context, status entities.PipelineStatus, limit, offset int) ([]*entities.Pipeline, error)
}

// GetPipelineQuery represents a query to get a pipeline by ID
type GetPipelineQuery struct {
        BaseQuery
        PipelineID entities.PipelineID
}

// NewGetPipelineQuery creates a new get pipeline query
func NewGetPipelineQuery(pipelineID entities.PipelineID) GetPipelineQuery <span class="cov0" title="0">{
        return GetPipelineQuery{
                BaseQuery:  NewBaseQuery("GetPipeline"),
                PipelineID: pipelineID,
        }
}</span>

// GetPipelineQueryHandler handles get pipeline queries
type GetPipelineQueryHandler struct {
        repository PipelineRepository
}

// NewGetPipelineQueryHandler creates a new get pipeline query handler
func NewGetPipelineQueryHandler(repository PipelineRepository) *GetPipelineQueryHandler <span class="cov0" title="0">{
        return &amp;GetPipelineQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the get pipeline query
func (h *GetPipelineQueryHandler) Handle(ctx context.Context, query GetPipelineQuery) result.Result[*entities.Pipeline] <span class="cov0" title="0">{
        pipeline, err := h.repository.FindByID(ctx, query.PipelineID)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[*entities.Pipeline](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        <span class="cov0" title="0">if pipeline == nil </span><span class="cov0" title="0">{
                return result.Failure[*entities.Pipeline](errors.NotFoundError("pipeline"))
        }</span>

        <span class="cov0" title="0">return result.Success(pipeline)</span>
}

// GetPipelineByNameQuery represents a query to get a pipeline by name
type GetPipelineByNameQuery struct {
        BaseQuery
        Name string
}

// NewGetPipelineByNameQuery creates a new get pipeline by name query
func NewGetPipelineByNameQuery(name string) GetPipelineByNameQuery <span class="cov0" title="0">{
        return GetPipelineByNameQuery{
                BaseQuery: NewBaseQuery("GetPipelineByName"),
                Name:      name,
        }
}</span>

// GetPipelineByNameQueryHandler handles get pipeline by name queries
type GetPipelineByNameQueryHandler struct {
        repository PipelineRepository
}

// NewGetPipelineByNameQueryHandler creates a new handler
func NewGetPipelineByNameQueryHandler(repository PipelineRepository) *GetPipelineByNameQueryHandler <span class="cov0" title="0">{
        return &amp;GetPipelineByNameQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *GetPipelineByNameQueryHandler) Handle(ctx context.Context, query GetPipelineByNameQuery) result.Result[*entities.Pipeline] <span class="cov0" title="0">{
        if query.Name == "" </span><span class="cov0" title="0">{
                return result.Failure[*entities.Pipeline](errors.ValidationError("pipeline name cannot be empty"))
        }</span>

        <span class="cov0" title="0">pipeline, err := h.repository.FindByName(ctx, query.Name)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[*entities.Pipeline](errors.Wrap(err, "failed to find pipeline"))
        }</span>

        <span class="cov0" title="0">if pipeline == nil </span><span class="cov0" title="0">{
                return result.Failure[*entities.Pipeline](errors.NotFoundError("pipeline"))
        }</span>

        <span class="cov0" title="0">return result.Success(pipeline)</span>
}

// ListPipelinesQuery represents a query to list pipelines
type ListPipelinesQuery struct {
        PagedQuery
}

// NewListPipelinesQuery creates a new list pipelines query
func NewListPipelinesQuery(page, pageSize int) ListPipelinesQuery <span class="cov0" title="0">{
        return ListPipelinesQuery{
                PagedQuery: NewPagedQuery("ListPipelines", page, pageSize),
        }
}</span>

// ListPipelinesQueryHandler handles list pipelines queries
type ListPipelinesQueryHandler struct {
        repository PipelineRepository
}

// NewListPipelinesQueryHandler creates a new handler
func NewListPipelinesQueryHandler(repository PipelineRepository) *ListPipelinesQueryHandler <span class="cov0" title="0">{
        return &amp;ListPipelinesQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *ListPipelinesQueryHandler) Handle(ctx context.Context, query ListPipelinesQuery) result.Result[PagedResult[*entities.Pipeline]] <span class="cov0" title="0">{
        // Calculate offset
        offset := (query.Page - 1) * query.PageSize

        // Get pipelines
        pipelines, err := h.repository.List(ctx, query.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to list pipelines"))
        }</span>

        // Get total count
        <span class="cov0" title="0">totalCount, err := h.repository.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to count pipelines"))
        }</span>

        // Create paged result
        <span class="cov0" title="0">pagedResult := NewPagedResult(pipelines, totalCount, query.Page, query.PageSize)
        return result.Success(pagedResult)</span>
}

// ListPipelinesByOwnerQuery represents a query to list pipelines by owner
type ListPipelinesByOwnerQuery struct {
        PagedQuery
        Owner string
}

// NewListPipelinesByOwnerQuery creates a new query
func NewListPipelinesByOwnerQuery(owner string, page, pageSize int) ListPipelinesByOwnerQuery <span class="cov0" title="0">{
        return ListPipelinesByOwnerQuery{
                PagedQuery: NewPagedQuery("ListPipelinesByOwner", page, pageSize),
                Owner:      owner,
        }
}</span>

// ListPipelinesByOwnerQueryHandler handles the query
type ListPipelinesByOwnerQueryHandler struct {
        repository PipelineRepository
}

// NewListPipelinesByOwnerQueryHandler creates a new handler
func NewListPipelinesByOwnerQueryHandler(repository PipelineRepository) *ListPipelinesByOwnerQueryHandler <span class="cov0" title="0">{
        return &amp;ListPipelinesByOwnerQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *ListPipelinesByOwnerQueryHandler) Handle(ctx context.Context, query ListPipelinesByOwnerQuery) result.Result[PagedResult[*entities.Pipeline]] <span class="cov0" title="0">{
        if query.Owner == "" </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.ValidationError("owner cannot be empty"))
        }</span>

        <span class="cov0" title="0">offset := (query.Page - 1) * query.PageSize
        pipelines, err := h.repository.FindByOwner(ctx, query.Owner, query.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to list pipelines by owner"))
        }</span>

        // For simplicity, using the same count. In production, implement CountByOwner
        <span class="cov0" title="0">totalCount, err := h.repository.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to count pipelines"))
        }</span>

        <span class="cov0" title="0">pagedResult := NewPagedResult(pipelines, totalCount, query.Page, query.PageSize)
        return result.Success(pagedResult)</span>
}

// ListPipelinesByTagQuery represents a query to list pipelines by tag
type ListPipelinesByTagQuery struct {
        PagedQuery
        Tag string
}

// NewListPipelinesByTagQuery creates a new query
func NewListPipelinesByTagQuery(tag string, page, pageSize int) ListPipelinesByTagQuery <span class="cov0" title="0">{
        return ListPipelinesByTagQuery{
                PagedQuery: NewPagedQuery("ListPipelinesByTag", page, pageSize),
                Tag:        tag,
        }
}</span>

// ListPipelinesByTagQueryHandler handles the query
type ListPipelinesByTagQueryHandler struct {
        repository PipelineRepository
}

// NewListPipelinesByTagQueryHandler creates a new handler
func NewListPipelinesByTagQueryHandler(repository PipelineRepository) *ListPipelinesByTagQueryHandler <span class="cov0" title="0">{
        return &amp;ListPipelinesByTagQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *ListPipelinesByTagQueryHandler) Handle(ctx context.Context, query ListPipelinesByTagQuery) result.Result[PagedResult[*entities.Pipeline]] <span class="cov0" title="0">{
        if query.Tag == "" </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.ValidationError("tag cannot be empty"))
        }</span>

        <span class="cov0" title="0">offset := (query.Page - 1) * query.PageSize
        pipelines, err := h.repository.FindByTag(ctx, query.Tag, query.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to list pipelines by tag"))
        }</span>

        <span class="cov0" title="0">totalCount, err := h.repository.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to count pipelines"))
        }</span>

        <span class="cov0" title="0">pagedResult := NewPagedResult(pipelines, totalCount, query.Page, query.PageSize)
        return result.Success(pagedResult)</span>
}

// ListPipelinesByStatusQuery represents a query to list pipelines by status
type ListPipelinesByStatusQuery struct {
        PagedQuery
        Status entities.PipelineStatus
}

// NewListPipelinesByStatusQuery creates a new query
func NewListPipelinesByStatusQuery(status entities.PipelineStatus, page, pageSize int) ListPipelinesByStatusQuery <span class="cov0" title="0">{
        return ListPipelinesByStatusQuery{
                PagedQuery: NewPagedQuery("ListPipelinesByStatus", page, pageSize),
                Status:     status,
        }
}</span>

// ListPipelinesByStatusQueryHandler handles the query
type ListPipelinesByStatusQueryHandler struct {
        repository PipelineRepository
}

// NewListPipelinesByStatusQueryHandler creates a new handler
func NewListPipelinesByStatusQueryHandler(repository PipelineRepository) *ListPipelinesByStatusQueryHandler <span class="cov0" title="0">{
        return &amp;ListPipelinesByStatusQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *ListPipelinesByStatusQueryHandler) Handle(ctx context.Context, query ListPipelinesByStatusQuery) result.Result[PagedResult[*entities.Pipeline]] <span class="cov0" title="0">{
        offset := (query.Page - 1) * query.PageSize
        pipelines, err := h.repository.FindByStatus(ctx, query.Status, query.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to list pipelines by status"))
        }</span>

        <span class="cov0" title="0">totalCount, err := h.repository.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to count pipelines"))
        }</span>

        <span class="cov0" title="0">pagedResult := NewPagedResult(pipelines, totalCount, query.Page, query.PageSize)
        return result.Success(pagedResult)</span>
}

// PipelineStatistics represents pipeline statistics
type PipelineStatistics struct {
        TotalPipelines       int
        ActivePipelines      int
        RunningPipelines     int
        FailedPipelines      int
        CompletedPipelines   int
        PipelinesLastHour    int
        PipelinesLastDay     int
        AverageExecutionTime time.Duration
}

// GetPipelineStatisticsQuery represents a query to get pipeline statistics
type GetPipelineStatisticsQuery struct {
        BaseQuery
}

// NewGetPipelineStatisticsQuery creates a new query
func NewGetPipelineStatisticsQuery() GetPipelineStatisticsQuery <span class="cov0" title="0">{
        return GetPipelineStatisticsQuery{
                BaseQuery: NewBaseQuery("GetPipelineStatistics"),
        }
}</span>

// GetPipelineStatisticsQueryHandler handles the query
type GetPipelineStatisticsQueryHandler struct {
        repository PipelineRepository
}

// NewGetPipelineStatisticsQueryHandler creates a new handler
func NewGetPipelineStatisticsQueryHandler(repository PipelineRepository) *GetPipelineStatisticsQueryHandler <span class="cov0" title="0">{
        return &amp;GetPipelineStatisticsQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *GetPipelineStatisticsQueryHandler) Handle(ctx context.Context, query GetPipelineStatisticsQuery) result.Result[PipelineStatistics] <span class="cov0" title="0">{
        // This is a simplified implementation
        // In production, you would have specific repository methods for statistics
        
        totalCount, err := h.repository.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PipelineStatistics](errors.Wrap(err, "failed to get pipeline count"))
        }</span>

        // Get counts by status
        <span class="cov0" title="0">activePipelines, _ := h.repository.FindByStatus(ctx, entities.PipelineStatusActive, 1000, 0)
        runningPipelines, _ := h.repository.FindByStatus(ctx, entities.PipelineStatusRunning, 1000, 0)
        failedPipelines, _ := h.repository.FindByStatus(ctx, entities.PipelineStatusFailed, 1000, 0)
        completedPipelines, _ := h.repository.FindByStatus(ctx, entities.PipelineStatusCompleted, 1000, 0)

        stats := PipelineStatistics{
                TotalPipelines:       totalCount,
                ActivePipelines:      len(activePipelines),
                RunningPipelines:     len(runningPipelines),
                FailedPipelines:      len(failedPipelines),
                CompletedPipelines:   len(completedPipelines),
                PipelinesLastHour:    0, // Would need time-based queries
                PipelinesLastDay:     0, // Would need time-based queries
                AverageExecutionTime: time.Minute * 5, // Would need execution data
        }

        return result.Success(stats)</span>
}

// SearchPipelinesQuery represents a query to search pipelines
type SearchPipelinesQuery struct {
        FilteredQuery
        PagedQuery
        SearchTerm string
}

// NewSearchPipelinesQuery creates a new query
func NewSearchPipelinesQuery(searchTerm string, page, pageSize int) SearchPipelinesQuery <span class="cov0" title="0">{
        return SearchPipelinesQuery{
                FilteredQuery: NewFilteredQuery("SearchPipelines"),
                PagedQuery:    NewPagedQuery("SearchPipelines", page, pageSize),
                SearchTerm:    searchTerm,
        }
}</span>

// SearchPipelinesQueryHandler handles the query
type SearchPipelinesQueryHandler struct {
        repository PipelineRepository
}

// NewSearchPipelinesQueryHandler creates a new handler
func NewSearchPipelinesQueryHandler(repository PipelineRepository) *SearchPipelinesQueryHandler <span class="cov0" title="0">{
        return &amp;SearchPipelinesQueryHandler{
                repository: repository,
        }
}</span>

// Handle handles the query
func (h *SearchPipelinesQueryHandler) Handle(ctx context.Context, query SearchPipelinesQuery) result.Result[PagedResult[*entities.Pipeline]] <span class="cov0" title="0">{
        if query.SearchTerm == "" </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.ValidationError("search term cannot be empty"))
        }</span>

        // In a real implementation, you would have a Search method in the repository
        // For now, we'll use the basic List method
        <span class="cov0" title="0">offset := (query.Page - 1) * query.PageSize
        pipelines, err := h.repository.List(ctx, query.PageSize, offset)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[PagedResult[*entities.Pipeline]](errors.Wrap(err, "failed to search pipelines"))
        }</span>

        // Filter by search term (simple implementation)
        <span class="cov0" title="0">filteredPipelines := make([]*entities.Pipeline, 0)
        for _, p := range pipelines </span><span class="cov0" title="0">{
                if contains(p.Name, query.SearchTerm) || contains(p.Description, query.SearchTerm) </span><span class="cov0" title="0">{
                        filteredPipelines = append(filteredPipelines, p)
                }</span>
        }

        <span class="cov0" title="0">totalCount := len(filteredPipelines)
        pagedResult := NewPagedResult(filteredPipelines, totalCount, query.Page, query.PageSize)
        return result.Success(pagedResult)</span>
}

// contains checks if s contains substr (case-insensitive)
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(substr) == 0 || (len(s) &gt; 0 &amp;&amp; len(substr) &gt; 0 &amp;&amp; strings.Contains(strings.ToLower(s), strings.ToLower(substr))))
}</pre>
		
		<pre class="file" id="file3" style="display: none">// Package queries provides CQRS query handling infrastructure
package queries

import (
        "context"
        "fmt"
        "reflect"
        "sync"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Query represents a query in the CQRS pattern
type Query interface {
        QueryType() string
}

// QueryHandler represents a handler for a specific query type
type QueryHandler[T Query, R any] interface {
        Handle(ctx context.Context, query T) result.Result[R]
}

// QueryBus coordinates query execution
type QueryBus interface {
        RegisterHandler(query Query, handler interface{}) error
        Execute(ctx context.Context, query Query) result.Result[interface{}]
}

// InMemoryQueryBus provides an in-memory implementation of QueryBus
type InMemoryQueryBus struct {
        mu       sync.RWMutex
        handlers map[string]interface{}
}

// NewInMemoryQueryBus creates a new in-memory query bus
func NewInMemoryQueryBus() *InMemoryQueryBus <span class="cov0" title="0">{
        return &amp;InMemoryQueryBus{
                handlers: make(map[string]interface{}),
        }
}</span>

// NewQueryBus creates a new query bus (returns interface)
func NewQueryBus() QueryBus <span class="cov0" title="0">{
        return NewInMemoryQueryBus()
}</span>

// RegisterHandler registers a query handler
func (bus *InMemoryQueryBus) RegisterHandler(query Query, handler interface{}) error <span class="cov0" title="0">{
        if query == nil </span><span class="cov0" title="0">{
                return errors.ValidationError("query cannot be nil")
        }</span>

        <span class="cov0" title="0">if handler == nil </span><span class="cov0" title="0">{
                return errors.ValidationError("handler cannot be nil")
        }</span>

        // Validate handler implements QueryHandler interface
        <span class="cov0" title="0">handlerType := reflect.TypeOf(handler)
        if !bus.isValidHandler(handlerType) </span><span class="cov0" title="0">{
                return errors.ValidationError("handler must implement QueryHandler interface")
        }</span>

        <span class="cov0" title="0">queryType := query.QueryType()
        
        bus.mu.Lock()
        defer bus.mu.Unlock()

        if _, exists := bus.handlers[queryType]; exists </span><span class="cov0" title="0">{
                return errors.AlreadyExistsError("handler for query type " + queryType)
        }</span>

        <span class="cov0" title="0">bus.handlers[queryType] = handler
        return nil</span>
}

// Execute executes a query
func (bus *InMemoryQueryBus) Execute(ctx context.Context, query Query) result.Result[interface{}] <span class="cov0" title="0">{
        if query == nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.ValidationError("query cannot be nil"))
        }</span>

        <span class="cov0" title="0">bus.mu.RLock()
        handler, exists := bus.handlers[query.QueryType()]
        bus.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.NotFoundError("handler for query type " + query.QueryType()))
        }</span>

        <span class="cov0" title="0">return bus.invokeHandler(ctx, handler, query)</span>
}

// isValidHandler checks if a type implements the QueryHandler interface
func (bus *InMemoryQueryBus) isValidHandler(handlerType reflect.Type) bool <span class="cov0" title="0">{
        // Check if it has a Handle method with correct signature
        method, exists := handlerType.MethodByName("Handle")
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check method signature: Handle(ctx context.Context, query T) result.Result[R]
        <span class="cov0" title="0">methodType := method.Type
        if methodType.NumIn() != 3 || methodType.NumOut() != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check context parameter
        <span class="cov0" title="0">contextType := reflect.TypeOf((*context.Context)(nil)).Elem()
        if !methodType.In(1).Implements(contextType) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check query parameter implements Query interface
        <span class="cov0" title="0">queryType := reflect.TypeOf((*Query)(nil)).Elem()
        if !methodType.In(2).Implements(queryType) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// invokeHandler invokes a query handler using reflection
func (bus *InMemoryQueryBus) invokeHandler(ctx context.Context, handler interface{}, query Query) result.Result[interface{}] <span class="cov0" title="0">{
        handlerValue := reflect.ValueOf(handler)
        handlerType := reflect.TypeOf(handler)

        method, exists := handlerType.MethodByName("Handle")
        if !exists </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.InternalError("handler does not have Handle method"))
        }</span>

        // Prepare arguments
        <span class="cov0" title="0">args := []reflect.Value{
                handlerValue,
                reflect.ValueOf(ctx),
                reflect.ValueOf(query),
        }

        // Call the handler method
        results := method.Func.Call(args)
        if len(results) != 1 </span><span class="cov0" title="0">{
                return result.Failure[interface{}](errors.InternalError("handler returned unexpected number of values"))
        }</span>

        // Extract the result
        <span class="cov0" title="0">resultValue := results[0].Interface()
        
        // Handle different result types
        switch v := resultValue.(type) </span>{
        case result.Result[interface{}]:<span class="cov0" title="0">
                return v</span>
        case error:<span class="cov0" title="0">
                if v != nil </span><span class="cov0" title="0">{
                        return result.Failure[interface{}](v)
                }</span>
                <span class="cov0" title="0">return result.Success[interface{}](nil)</span>
        default:<span class="cov0" title="0">
                // If it's not a Result type, wrap it
                return result.Success[interface{}](v)</span>
        }
}

// GetRegisteredQueries returns all registered query types
func (bus *InMemoryQueryBus) GetRegisteredQueries() []string <span class="cov0" title="0">{
        bus.mu.RLock()
        defer bus.mu.RUnlock()

        queries := make([]string, 0, len(bus.handlers))
        for queryType := range bus.handlers </span><span class="cov0" title="0">{
                queries = append(queries, queryType)
        }</span>
        <span class="cov0" title="0">return queries</span>
}

// BaseQuery provides a base implementation for queries
type BaseQuery struct {
        queryType string
}

// NewBaseQuery creates a new base query
func NewBaseQuery(queryType string) BaseQuery <span class="cov0" title="0">{
        return BaseQuery{queryType: queryType}
}</span>

// QueryType returns the query type
func (q BaseQuery) QueryType() string <span class="cov0" title="0">{
        return q.queryType
}</span>

// PagedQuery represents a query with pagination
type PagedQuery struct {
        BaseQuery
        Page     int
        PageSize int
        OrderBy  string
        Order    string // ASC or DESC
}

// NewPagedQuery creates a new paged query
func NewPagedQuery(queryType string, page, pageSize int) PagedQuery <span class="cov0" title="0">{
        return PagedQuery{
                BaseQuery: NewBaseQuery(queryType),
                Page:      page,
                PageSize:  pageSize,
                Order:     "ASC",
        }
}</span>

// WithOrderBy sets the order by field
func (q PagedQuery) WithOrderBy(field string, order string) PagedQuery <span class="cov0" title="0">{
        q.OrderBy = field
        q.Order = order
        return q
}</span>

// PagedResult represents a paged result
type PagedResult[T any] struct {
        Items      []T
        TotalCount int
        Page       int
        PageSize   int
        TotalPages int
}

// NewPagedResult creates a new paged result
func NewPagedResult[T any](items []T, totalCount, page, pageSize int) PagedResult[T] <span class="cov0" title="0">{
        totalPages := (totalCount + pageSize - 1) / pageSize
        return PagedResult[T]{
                Items:      items,
                TotalCount: totalCount,
                Page:       page,
                PageSize:   pageSize,
                TotalPages: totalPages,
        }
}</span>

// HasNextPage returns true if there is a next page
func (pr PagedResult[T]) HasNextPage() bool <span class="cov0" title="0">{
        return pr.Page &lt; pr.TotalPages
}</span>

// HasPreviousPage returns true if there is a previous page
func (pr PagedResult[T]) HasPreviousPage() bool <span class="cov0" title="0">{
        return pr.Page &gt; 1
}</span>

// FilteredQuery represents a query with filters
type FilteredQuery struct {
        BaseQuery
        Filters map[string]interface{}
}

// NewFilteredQuery creates a new filtered query
func NewFilteredQuery(queryType string) FilteredQuery <span class="cov0" title="0">{
        return FilteredQuery{
                BaseQuery: NewBaseQuery(queryType),
                Filters:   make(map[string]interface{}),
        }
}</span>

// WithFilter adds a filter
func (q FilteredQuery) WithFilter(key string, value interface{}) FilteredQuery <span class="cov0" title="0">{
        q.Filters[key] = value
        return q
}</span>

// QueryCache provides caching for query results
type QueryCache struct {
        cache map[string]interface{}
        mu    sync.RWMutex
}

// NewQueryCache creates a new query cache
func NewQueryCache() *QueryCache <span class="cov0" title="0">{
        return &amp;QueryCache{
                cache: make(map[string]interface{}),
        }
}</span>

// Get retrieves a cached result
func (c *QueryCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        value, exists := c.cache[key]
        return value, exists
}</span>

// Set stores a result in cache
func (c *QueryCache) Set(key string, value interface{}) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.cache[key] = value
}</span>

// Clear clears the cache
func (c *QueryCache) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.cache = make(map[string]interface{})
}</span>

// CachedQueryBus wraps a query bus with caching
type CachedQueryBus struct {
        inner QueryBus
        cache *QueryCache
}

// NewCachedQueryBus creates a new cached query bus
func NewCachedQueryBus(inner QueryBus) *CachedQueryBus <span class="cov0" title="0">{
        return &amp;CachedQueryBus{
                inner: inner,
                cache: NewQueryCache(),
        }
}</span>

// RegisterHandler registers a query handler
func (bus *CachedQueryBus) RegisterHandler(query Query, handler interface{}) error <span class="cov0" title="0">{
        return bus.inner.RegisterHandler(query, handler)
}</span>

// Execute executes a query with caching
func (bus *CachedQueryBus) Execute(ctx context.Context, query Query) result.Result[interface{}] <span class="cov0" title="0">{
        // Generate cache key
        cacheKey := fmt.Sprintf("%s:%v", query.QueryType(), query)
        
        // Check cache
        if cached, exists := bus.cache.Get(cacheKey); exists </span><span class="cov0" title="0">{
                return result.Success(cached)
        }</span>
        
        // Execute query
        <span class="cov0" title="0">result := bus.inner.Execute(ctx, query)
        
        // Cache successful results
        if result.IsSuccess() </span><span class="cov0" title="0">{
                bus.cache.Set(cacheKey, result.Value())
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// InvalidateCache clears the cache
func (bus *CachedQueryBus) InvalidateCache() <span class="cov0" title="0">{
        bus.cache.Clear()
}</span>

// QueryBusBuilder helps build query bus configurations
type QueryBusBuilder struct {
        enableCache bool
}

// NewQueryBusBuilder creates a new query bus builder
func NewQueryBusBuilder() *QueryBusBuilder <span class="cov0" title="0">{
        return &amp;QueryBusBuilder{}
}</span>

// WithCache enables caching
func (b *QueryBusBuilder) WithCache() *QueryBusBuilder <span class="cov0" title="0">{
        b.enableCache = true
        return b
}</span>

// Build creates the query bus
func (b *QueryBusBuilder) Build() QueryBus <span class="cov0" title="0">{
        inner := NewInMemoryQueryBus()
        
        if b.enableCache </span><span class="cov0" title="0">{
                return NewCachedQueryBus(inner)
        }</span>
        
        <span class="cov0" title="0">return inner</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">// FlexCore - Professional distributed event-driven architecture
package main

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/flext/flexcore/internal/domain"
        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Version information (set by build flags)
var (
        Version    = "dev"
        BuildTime  = "unknown"
        CommitHash = "unknown"
)

// Server represents the FlexCore HTTP server
type Server struct {
        core   *domain.FlexCore
        router *mux.Router
        config *domain.FlexCoreConfig
}

// NewServer creates a new FlexCore server
func NewServer(config *domain.FlexCoreConfig) (*Server, error) <span class="cov0" title="0">{
        // Create FlexCore instance
        coreResult := domain.NewFlexCore(config)
        if coreResult.IsFailure() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create FlexCore: %v", coreResult.Error())
        }</span>

        <span class="cov0" title="0">server := &amp;Server{
                core:   coreResult.Value(),
                config: config,
        }

        // Setup routes
        server.setupRoutes()

        return server, nil</span>
}

// setupRoutes configures all HTTP routes
func (s *Server) setupRoutes() <span class="cov0" title="0">{
        s.router = mux.NewRouter()

        // Health &amp; Info
        s.router.HandleFunc("/health", s.handleHealth).Methods("GET")
        s.router.HandleFunc("/info", s.handleInfo).Methods("GET")
        s.router.HandleFunc("/metrics", promhttp.Handler().ServeHTTP).Methods("GET")

        // Event handling
        s.router.HandleFunc("/events", s.handleSendEvent).Methods("POST")
        s.router.HandleFunc("/events/batch", s.handleBatchEvents).Methods("POST")

        // Message queue
        s.router.HandleFunc("/queues/{queue}/messages", s.handleSendMessage).Methods("POST")
        s.router.HandleFunc("/queues/{queue}/messages", s.handleReceiveMessages).Methods("GET")

        // Workflow execution
        s.router.HandleFunc("/workflows/execute", s.handleExecuteWorkflow).Methods("POST")
        s.router.HandleFunc("/workflows/{id}/status", s.handleWorkflowStatus).Methods("GET")

        // Cluster management
        s.router.HandleFunc("/cluster/status", s.handleClusterStatus).Methods("GET")
}</span>

// Start starts the server
func (s *Server) Start(port string) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Start FlexCore
        if startResult := s.core.Start(ctx); startResult.IsFailure() </span><span class="cov0" title="0">{
                log.Printf("Warning: FlexCore start returned: %v", startResult.Error())
        }</span>

        // Start HTTP server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      s.router,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // Handle graceful shutdown
        go func() </span><span class="cov0" title="0">{
                sigChan := make(chan os.Signal, 1)
                signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
                &lt;-sigChan

                log.Println("Shutting down server...")
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()

                srv.Shutdown(ctx)
                s.core.Stop(ctx)
        }</span>()

        <span class="cov0" title="0">log.Printf("FlexCore server listening on port %s", port)
        log.Printf("Version: %s, Build: %s, Commit: %s", Version, BuildTime, CommitHash)
        return srv.ListenAndServe()</span>
}

// HTTP Handlers

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "status":     "healthy",
                "timestamp":  time.Now().Unix(),
                "version":    Version,
                "build_time": BuildTime,
                "commit":     CommitHash,
        })
}</span>

func (s *Server) handleInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "service":    "flexcore",
                "version":    Version,
                "build_time": BuildTime,
                "commit":     CommitHash,
                "node_id":    s.config.NodeID,
                "cluster":    s.config.ClusterName,
                "uptime":     time.Since(time.Now()).Seconds(), // Would track actual start time
        })
}</span>

func (s *Server) handleSendEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var eventData struct {
                Type        string                 `json:"type"`
                AggregateID string                 `json:"aggregate_id"`
                Data        map[string]interface{} `json:"data"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;eventData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if eventData.Type == "" </span><span class="cov0" title="0">{
                http.Error(w, "Event type is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">event := domain.NewEvent(eventData.Type, eventData.AggregateID, eventData.Data)
        result := s.core.SendEvent(r.Context(), event)
        
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "id":     event.ID,
                "status": "accepted",
        })</span>
}

func (s *Server) handleBatchEvents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var events []struct {
                Type        string                 `json:"type"`
                AggregateID string                 `json:"aggregate_id"`
                Data        map[string]interface{} `json:"data"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;events); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">results := make([]map[string]interface{}, 0, len(events))
        
        for _, eventData := range events </span><span class="cov0" title="0">{
                event := domain.NewEvent(eventData.Type, eventData.AggregateID, eventData.Data)
                result := s.core.SendEvent(r.Context(), event)
                
                status := "accepted"
                if result.IsFailure() </span><span class="cov0" title="0">{
                        status = "failed"
                }</span>

                <span class="cov0" title="0">results = append(results, map[string]interface{}{
                        "id":     event.ID,
                        "status": status,
                })</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "results": results,
                "total":   len(results),
        })</span>
}

func (s *Server) handleSendMessage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        queue := vars["queue"]
        
        var messageData map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;messageData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">message := domain.NewMessage(queue, messageData)
        result := s.core.SendMessage(r.Context(), queue, message)
        
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "id":     message.ID,
                "queue":  queue,
                "status": "queued",
        })</span>
}

func (s *Server) handleReceiveMessages(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        queue := vars["queue"]
        maxMessages := 10 // Could be from query param
        
        result := s.core.ReceiveMessages(r.Context(), queue, maxMessages)
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">messages := result.Value()
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "messages": messages,
                "count":    len(messages),
                "queue":    queue,
        })</span>
}

func (s *Server) handleExecuteWorkflow(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Path  string                 `json:"path"`
                Input map[string]interface{} `json:"input"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                http.Error(w, "Workflow path is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result := s.core.ExecuteWorkflow(r.Context(), req.Path, req.Input)
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "job_id": result.Value(),
                "status": "started",
        })</span>
}

func (s *Server) handleWorkflowStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        jobID := vars["id"]
        
        result := s.core.GetWorkflowStatus(r.Context(), jobID)
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result.Value())</span>
}

func (s *Server) handleClusterStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        result := s.core.GetClusterStatus(r.Context())
        if result.IsFailure() </span><span class="cov0" title="0">{
                http.Error(w, result.Error().Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result.Value())</span>
}

func main() <span class="cov0" title="0">{
        // Parse flags
        var (
                configFile = flag.String("config", "", "Configuration file (optional)")
                port       = flag.String("port", "8080", "HTTP server port")
                nodeID     = flag.String("node", "", "Node ID (auto-generated if empty)")
                help       = flag.Bool("help", false, "Show help")
                version    = flag.Bool("version", false, "Show version")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                flag.Usage()
                return
        }</span>

        <span class="cov0" title="0">if *version </span><span class="cov0" title="0">{
                fmt.Printf("FlexCore %s (build %s, commit %s)\n", Version, BuildTime, CommitHash)
                return
        }</span>

        // Create configuration
        <span class="cov0" title="0">config := domain.DefaultConfig()
        if *nodeID != "" </span><span class="cov0" title="0">{
                config.NodeID = *nodeID
        }</span>

        // TODO: Load from config file if provided
        <span class="cov0" title="0">if *configFile != "" </span><span class="cov0" title="0">{
                log.Printf("Loading configuration from %s", *configFile)
                // Implementation would load from file
        }</span>

        // Override from environment variables
        <span class="cov0" title="0">if url := os.Getenv("WINDMILL_URL"); url != "" </span><span class="cov0" title="0">{
                config.WindmillURL = url
        }</span>
        <span class="cov0" title="0">if token := os.Getenv("WINDMILL_TOKEN"); token != "" </span><span class="cov0" title="0">{
                config.WindmillToken = token
        }</span>
        <span class="cov0" title="0">if workspace := os.Getenv("WINDMILL_WORKSPACE"); workspace != "" </span><span class="cov0" title="0">{
                config.WindmillWorkspace = workspace
        }</span>

        <span class="cov0" title="0">log.Printf("Starting FlexCore node: %s", config.NodeID)

        // Create and start server
        server, err := NewServer(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create server: %v", err)
        }</span>

        <span class="cov0" title="0">if err := server.Start(*port); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                log.Fatalf("Server failed: %v", err)
        }</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">// Package core - DEPRECATED: Use internal/domain instead
//
// This package is deprecated and will be removed in v2.0.0.
// Please migrate to github.com/flext/flexcore/internal/domain
package core

import (
        "log"
        "os"
        "runtime"
        "sync"

        "github.com/flext/flexcore/internal/domain"
)

var (
        deprecationWarnings sync.Map
        deprecationOnce     sync.Once
)

// DEPRECATED: Use internal/domain.FlexCore instead
// This type will be removed in v2.0.0
type FlexCore = domain.FlexCore

// DEPRECATED: Use internal/domain.FlexCoreConfig instead
// This type will be removed in v2.0.0
type FlexCoreConfig = domain.FlexCoreConfig

// DEPRECATED: Use internal/domain.Event instead
// This type will be removed in v2.0.0
type Event = domain.Event

// DEPRECATED: Use internal/domain.Message instead
// This type will be removed in v2.0.0
type Message = domain.Message

// Note: Generic type aliases require Go 1.23+
// For now, we'll use a struct wrapper for compatibility

func init() <span class="cov0" title="0">{
        // Show deprecation warning once per process
        deprecationOnce.Do(func() </span><span class="cov0" title="0">{
                if os.Getenv("FLEXCORE_HIDE_DEPRECATION_WARNINGS") != "true" </span><span class="cov0" title="0">{
                        log.Printf(" DEPRECATION WARNING: Package 'core' is deprecated. Use 'internal/domain' instead.")
                        log.Printf("   This package will be removed in FlexCore v2.0.0")
                        log.Printf("   Set FLEXCORE_HIDE_DEPRECATION_WARNINGS=true to hide this warning")
                        log.Printf("   Migration guide: https://github.com/flext/flexcore/docs/migration-v2.md")
                }</span>
        })
}

// logDeprecatedUsage logs when a deprecated function is used
func logDeprecatedUsage(functionName string) <span class="cov0" title="0">{
        // Only warn once per function per process
        if _, warned := deprecationWarnings.LoadOrStore(functionName, true); !warned </span><span class="cov0" title="0">{
                _, file, line, _ := runtime.Caller(2)
                log.Printf(" DEPRECATED: %s used at %s:%d - migrate to internal/domain", functionName, file, line)
        }</span>
}

// DEPRECATED: Use internal/domain.NewFlexCore instead
// This function will be removed in v2.0.0
func NewFlexCore(config *FlexCoreConfig) *domain.Result[*FlexCore] <span class="cov0" title="0">{
        logDeprecatedUsage("NewFlexCore")
        return domain.NewFlexCore(config)
}</span>

// DEPRECATED: Use internal/domain.DefaultConfig instead
// This function will be removed in v2.0.0
func DefaultConfig() *FlexCoreConfig <span class="cov0" title="0">{
        logDeprecatedUsage("DefaultConfig")
        return domain.DefaultConfig()
}</span>

// DEPRECATED: Use internal/domain.NewEvent instead
// This function will be removed in v2.0.0
func NewEvent(eventType, aggregateID string, data map[string]interface{}) *Event <span class="cov0" title="0">{
        logDeprecatedUsage("NewEvent")
        return domain.NewEvent(eventType, aggregateID, data)
}</span>

// DEPRECATED: Use internal/domain.NewMessage instead
// This function will be removed in v2.0.0
func NewMessage(queue string, data map[string]interface{}) *Message <span class="cov0" title="0">{
        logDeprecatedUsage("NewMessage")
        return domain.NewMessage(queue, data)
}</span>

// DEPRECATED: Use internal/domain.NewSuccess instead
// This function will be removed in v2.0.0
func NewSuccess[T any](value T) *domain.Result[T] <span class="cov0" title="0">{
        logDeprecatedUsage("NewSuccess")
        return domain.NewSuccess(value)
}</span>

// DEPRECATED: Use internal/domain.NewFailure instead
// This function will be removed in v2.0.0
func NewFailure[T any](err error) *domain.Result[T] <span class="cov0" title="0">{
        logDeprecatedUsage("NewFailure")
        return domain.NewFailure[T](err)
}</pre>
		
		<pre class="file" id="file6" style="display: none">// Package domain provides the core domain layer types and patterns
package domain

import (
        "time"

        "github.com/google/uuid"
)

// Entity represents a domain entity with identity
type Entity[T comparable] struct {
        ID        T
        CreatedAt time.Time
        UpdatedAt time.Time
        Version   int64
}

// NewEntity creates a new entity with the given ID
func NewEntity[T comparable](id T) Entity[T] <span class="cov6" title="8">{
        now := time.Now()
        return Entity[T]{
                ID:        id,
                CreatedAt: now,
                UpdatedAt: now,
                Version:   1,
        }
}</span>

// Touch updates the entity's timestamp and version
func (e *Entity[T]) Touch() <span class="cov1" title="1">{
        e.UpdatedAt = time.Now()
        e.Version++
}</span>

// Equals compares two entities by ID
func (e *Entity[T]) Equals(other Entity[T]) bool <span class="cov2" title="2">{
        return e.ID == other.ID
}</span>

// ValueObject represents an immutable value object
type ValueObject interface {
        Equals(other ValueObject) bool
        String() string
}

// AggregateRoot represents a domain aggregate root
type AggregateRoot[T comparable] struct {
        Entity[T]
        domainEvents []DomainEvent
}

// NewAggregateRoot creates a new aggregate root
func NewAggregateRoot[T comparable](id T) AggregateRoot[T] <span class="cov4" title="3">{
        return AggregateRoot[T]{
                Entity:       NewEntity(id),
                domainEvents: make([]DomainEvent, 0),
        }
}</span>

// RaiseEvent adds a domain event to the aggregate
func (ar *AggregateRoot[T]) RaiseEvent(event DomainEvent) <span class="cov4" title="3">{
        ar.domainEvents = append(ar.domainEvents, event)
}</span>

// DomainEvents returns all raised domain events
func (ar *AggregateRoot[T]) DomainEvents() []DomainEvent <span class="cov5" title="5">{
        return ar.domainEvents
}</span>

// ClearEvents clears all domain events
func (ar *AggregateRoot[T]) ClearEvents() <span class="cov1" title="1">{
        ar.domainEvents = make([]DomainEvent, 0)
}</span>

// DomainEvent represents a domain event
type DomainEvent interface {
        EventID() string
        EventType() string
        OccurredAt() time.Time
        AggregateID() string
}

// BaseDomainEvent provides a base implementation for domain events
type BaseDomainEvent struct {
        ID          string
        Type        string
        Timestamp   time.Time
        AggregateId string
}

// NewBaseDomainEvent creates a new base domain event
func NewBaseDomainEvent(eventType, aggregateID string) BaseDomainEvent <span class="cov1" title="1">{
        return BaseDomainEvent{
                ID:          uuid.New().String(),
                Type:        eventType,
                Timestamp:   time.Now(),
                AggregateId: aggregateID,
        }
}</span>

// EventID returns the event ID
func (e BaseDomainEvent) EventID() string <span class="cov1" title="1">{
        return e.ID
}</span>

// EventType returns the event type
func (e BaseDomainEvent) EventType() string <span class="cov1" title="1">{
        return e.Type
}</span>

// OccurredAt returns when the event occurred
func (e BaseDomainEvent) OccurredAt() time.Time <span class="cov2" title="2">{
        return e.Timestamp
}</span>

// AggregateID returns the aggregate ID
func (e BaseDomainEvent) AggregateID() string <span class="cov1" title="1">{
        return e.AggregateId
}</span>

// CreatePluginEvent creates a plugin-related domain event
func CreatePluginEvent(eventType, pluginID string, data map[string]interface{}) DomainEvent <span class="cov0" title="0">{
        return NewBaseDomainEvent(eventType, pluginID)
}</span>

// CreatePipelineEvent creates a pipeline-related domain event
func CreatePipelineEvent(eventType, pipelineID string, data map[string]interface{}) DomainEvent <span class="cov0" title="0">{
        return NewBaseDomainEvent(eventType, pipelineID)
}</span>

// CreateSystemEvent creates a system-related domain event
func CreateSystemEvent(eventType string, data map[string]interface{}) DomainEvent <span class="cov0" title="0">{
        return NewBaseDomainEvent(eventType, "")
}</span>

// Repository represents a domain repository
type Repository[T any, ID comparable] interface {
        Save(entity T) error
        FindByID(id ID) (T, error)
        Delete(id ID) error
        Exists(id ID) bool
}

// Specification represents a domain specification pattern
type Specification[T any] interface {
        IsSatisfiedBy(entity T) bool
        And(other Specification[T]) Specification[T]
        Or(other Specification[T]) Specification[T]
        Not() Specification[T]
}

// BaseSpecification provides a base implementation for specifications
type BaseSpecification[T any] struct {
        predicate func(T) bool
}

// NewSpecification creates a new specification with the given predicate
func NewSpecification[T any](predicate func(T) bool) Specification[T] <span class="cov5" title="5">{
        return &amp;BaseSpecification[T]{predicate: predicate}
}</span>

// IsSatisfiedBy checks if the entity satisfies the specification
func (s *BaseSpecification[T]) IsSatisfiedBy(entity T) bool <span class="cov10" title="23">{
        return s.predicate(entity)
}</span>

// And combines two specifications with AND logic
func (s *BaseSpecification[T]) And(other Specification[T]) Specification[T] <span class="cov1" title="1">{
        return NewSpecification(func(entity T) bool </span><span class="cov4" title="3">{
                return s.IsSatisfiedBy(entity) &amp;&amp; other.IsSatisfiedBy(entity)
        }</span>)
}

// Or combines two specifications with OR logic
func (s *BaseSpecification[T]) Or(other Specification[T]) Specification[T] <span class="cov1" title="1">{
        return NewSpecification(func(entity T) bool </span><span class="cov4" title="3">{
                return s.IsSatisfiedBy(entity) || other.IsSatisfiedBy(entity)
        }</span>)
}

// Not negates the specification
func (s *BaseSpecification[T]) Not() Specification[T] <span class="cov1" title="1">{
        return NewSpecification(func(entity T) bool </span><span class="cov2" title="2">{
                return !s.IsSatisfiedBy(entity)
        }</span>)
}

// DomainService represents a domain service
type DomainService interface {
        Name() string
}

// BaseDomainService provides a base implementation for domain services
type BaseDomainService struct {
        name string
}

// NewDomainService creates a new domain service
func NewDomainService(name string) BaseDomainService <span class="cov1" title="1">{
        return BaseDomainService{name: name}
}</span>

// Name returns the service name
func (s BaseDomainService) Name() string <span class="cov1" title="1">{
        return s.name
}</pre>
		
		<pre class="file" id="file7" style="display: none">// Package entities contains domain entities for FlexCore
package entities

import (
        "time"

        "github.com/flext/flexcore/domain"
        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
        "github.com/google/uuid"
)

// PipelineID represents a unique pipeline identifier
type PipelineID string

// NewPipelineID creates a new pipeline ID
func NewPipelineID() PipelineID <span class="cov7" title="13">{
        return PipelineID(uuid.New().String())
}</span>

// String returns the string representation of the pipeline ID
func (id PipelineID) String() string <span class="cov10" title="40">{
        return string(id)
}</span>

// PipelineStatus represents the status of a pipeline
type PipelineStatus int

const (
        PipelineStatusDraft PipelineStatus = iota
        PipelineStatusActive
        PipelineStatusRunning
        PipelineStatusCompleted
        PipelineStatusFailed
        PipelineStatusPaused
        PipelineStatusArchived
)

// String returns the string representation of the pipeline status
func (s PipelineStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case PipelineStatusDraft:<span class="cov0" title="0">
                return "draft"</span>
        case PipelineStatusActive:<span class="cov0" title="0">
                return "active"</span>
        case PipelineStatusRunning:<span class="cov0" title="0">
                return "running"</span>
        case PipelineStatusCompleted:<span class="cov0" title="0">
                return "completed"</span>
        case PipelineStatusFailed:<span class="cov0" title="0">
                return "failed"</span>
        case PipelineStatusPaused:<span class="cov0" title="0">
                return "paused"</span>
        case PipelineStatusArchived:<span class="cov0" title="0">
                return "archived"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// PipelineStep represents a step in a pipeline
type PipelineStep struct {
        ID          string
        Name        string
        Type        string
        Config      map[string]interface{}
        DependsOn   []string
        RetryCount  int
        MaxRetries  int
        Timeout     time.Duration
        IsEnabled   bool
        CreatedAt   time.Time
}

// NewPipelineStep creates a new pipeline step
func NewPipelineStep(name, stepType string) PipelineStep <span class="cov0" title="0">{
        return PipelineStep{
                ID:         uuid.New().String(),
                Name:       name,
                Type:       stepType,
                Config:     make(map[string]interface{}),
                DependsOn:  make([]string, 0),
                RetryCount: 0,
                MaxRetries: 3,
                Timeout:    time.Minute * 30,
                IsEnabled:  true,
                CreatedAt:  time.Now(),
        }
}</span>

// Pipeline represents a data processing pipeline
type Pipeline struct {
        domain.AggregateRoot[PipelineID]
        Name        string
        Description string
        Status      PipelineStatus
        Steps       []PipelineStep
        Tags        []string
        Owner       string
        Schedule    *PipelineSchedule
        LastRunAt   *time.Time
        NextRunAt   *time.Time
}

// PipelineSchedule represents a pipeline schedule
type PipelineSchedule struct {
        CronExpression string
        Timezone       string
        IsEnabled      bool
        CreatedAt      time.Time
}

// NewPipeline creates a new pipeline
func NewPipeline(name, description, owner string) result.Result[*Pipeline] <span class="cov7" title="13">{
        if name == "" </span><span class="cov0" title="0">{
                return result.Failure[*Pipeline](errors.ValidationError("pipeline name cannot be empty"))
        }</span>

        <span class="cov7" title="13">if owner == "" </span><span class="cov0" title="0">{
                return result.Failure[*Pipeline](errors.ValidationError("pipeline owner cannot be empty"))
        }</span>

        <span class="cov7" title="13">id := NewPipelineID()
        pipeline := &amp;Pipeline{
                AggregateRoot: domain.NewAggregateRoot(id),
                Name:          name,
                Description:   description,
                Status:        PipelineStatusDraft,
                Steps:         make([]PipelineStep, 0),
                Tags:          make([]string, 0),
                Owner:         owner,
        }

        // Raise domain event
        event := NewPipelineCreatedEvent(id, name, owner)
        pipeline.RaiseEvent(event)

        return result.Success(pipeline)</span>
}

// AddStep adds a step to the pipeline
func (p *Pipeline) AddStep(step PipelineStep) result.Result[bool] <span class="cov6" title="11">{
        if step.Name == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("step name cannot be empty"))
        }</span>

        // Check for duplicate step names
        <span class="cov6" title="11">for _, existingStep := range p.Steps </span><span class="cov3" title="3">{
                if existingStep.Name == step.Name </span><span class="cov1" title="1">{
                        return result.Failure[bool](errors.AlreadyExistsError("step with name " + step.Name))
                }</span>
        }

        // Validate dependencies
        <span class="cov6" title="10">for _, dependency := range step.DependsOn </span><span class="cov0" title="0">{
                if !p.hasStep(dependency) </span><span class="cov0" title="0">{
                        return result.Failure[bool](errors.ValidationError("dependency step not found: " + dependency))
                }</span>
        }

        <span class="cov6" title="10">p.Steps = append(p.Steps, step)
        p.Touch()

        // Raise domain event
        event := NewPipelineStepAddedEvent(p.ID, step.ID, step.Name)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// RemoveStep removes a step from the pipeline
func (p *Pipeline) RemoveStep(stepName string) result.Result[bool] <span class="cov3" title="3">{
        stepIndex := -1
        for i, step := range p.Steps </span><span class="cov3" title="3">{
                if step.Name == stepName </span><span class="cov2" title="2">{
                        stepIndex = i
                        break</span>
                }
        }

        <span class="cov3" title="3">if stepIndex == -1 </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.NotFoundError("step " + stepName))
        }</span>

        // Check if other steps depend on this step
        <span class="cov2" title="2">for _, step := range p.Steps </span><span class="cov3" title="3">{
                for _, dependency := range step.DependsOn </span><span class="cov0" title="0">{
                        if dependency == stepName </span><span class="cov0" title="0">{
                                return result.Failure[bool](errors.ValidationError("cannot remove step: other steps depend on it"))
                        }</span>
                }
        }

        // Remove the step
        <span class="cov2" title="2">p.Steps = append(p.Steps[:stepIndex], p.Steps[stepIndex+1:]...)
        p.Touch()

        // Raise domain event
        event := NewPipelineStepRemovedEvent(p.ID, stepName)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// Activate activates the pipeline
func (p *Pipeline) Activate() result.Result[bool] <span class="cov5" title="6">{
        if p.Status == PipelineStatusActive </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("pipeline is already active"))
        }</span>

        <span class="cov5" title="6">if len(p.Steps) == 0 </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("cannot activate pipeline without steps"))
        }</span>

        <span class="cov5" title="6">p.Status = PipelineStatusActive
        p.Touch()

        // Raise domain event
        event := NewPipelineActivatedEvent(p.ID, p.Name)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// Deactivate deactivates the pipeline
func (p *Pipeline) Deactivate() result.Result[bool] <span class="cov1" title="1">{
        if p.Status == PipelineStatusRunning </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("cannot deactivate running pipeline"))
        }</span>

        <span class="cov1" title="1">p.Status = PipelineStatusDraft
        p.Touch()

        // Raise domain event
        event := NewPipelineDeactivatedEvent(p.ID, p.Name)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// Start starts the pipeline execution
func (p *Pipeline) Start() result.Result[bool] <span class="cov4" title="5">{
        if p.Status != PipelineStatusActive </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("can only start active pipelines"))
        }</span>

        <span class="cov4" title="4">if p.Status == PipelineStatusRunning </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("pipeline is already running"))
        }</span>

        <span class="cov4" title="4">p.Status = PipelineStatusRunning
        now := time.Now()
        p.LastRunAt = &amp;now
        p.Touch()

        // Raise domain event
        event := NewPipelineStartedEvent(p.ID, p.Name, now)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// Complete marks the pipeline as completed
func (p *Pipeline) Complete() result.Result[bool] <span class="cov2" title="2">{
        if p.Status != PipelineStatusRunning </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("can only complete running pipelines"))
        }</span>

        <span class="cov1" title="1">p.Status = PipelineStatusCompleted
        p.Touch()

        // Raise domain event
        event := NewPipelineCompletedEvent(p.ID, p.Name, time.Now())
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// Fail marks the pipeline as failed
func (p *Pipeline) Fail(reason string) result.Result[bool] <span class="cov2" title="2">{
        if p.Status != PipelineStatusRunning </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("can only fail running pipelines"))
        }</span>

        <span class="cov1" title="1">p.Status = PipelineStatusFailed
        p.Touch()

        // Raise domain event
        event := NewPipelineFailedEvent(p.ID, p.Name, reason, time.Now())
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// SetSchedule sets the pipeline schedule
func (p *Pipeline) SetSchedule(cronExpression, timezone string) result.Result[bool] <span class="cov1" title="1">{
        if cronExpression == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("cron expression cannot be empty"))
        }</span>

        <span class="cov1" title="1">p.Schedule = &amp;PipelineSchedule{
                CronExpression: cronExpression,
                Timezone:       timezone,
                IsEnabled:      true,
                CreatedAt:      time.Now(),
        }
        p.Touch()

        // Raise domain event
        event := NewPipelineScheduleSetEvent(p.ID, cronExpression, timezone)
        p.RaiseEvent(event)

        return result.Success(true)</span>
}

// ClearSchedule removes the pipeline schedule
func (p *Pipeline) ClearSchedule() <span class="cov1" title="1">{
        p.Schedule = nil
        p.Touch()

        // Raise domain event
        event := NewPipelineScheduleClearedEvent(p.ID)
        p.RaiseEvent(event)
}</span>

// AddTag adds a tag to the pipeline
func (p *Pipeline) AddTag(tag string) <span class="cov6" title="9">{
        for _, existingTag := range p.Tags </span><span class="cov6" title="8">{
                if existingTag == tag </span><span class="cov1" title="1">{
                        return // Tag already exists
                }</span>
        }
        <span class="cov6" title="8">p.Tags = append(p.Tags, tag)
        p.Touch()</span>
}

// RemoveTag removes a tag from the pipeline
func (p *Pipeline) RemoveTag(tag string) <span class="cov2" title="2">{
        for i, existingTag := range p.Tags </span><span class="cov4" title="4">{
                if existingTag == tag </span><span class="cov1" title="1">{
                        p.Tags = append(p.Tags[:i], p.Tags[i+1:]...)
                        p.Touch()
                        break</span>
                }
        }
}

// hasStep checks if a step with the given name exists
func (p *Pipeline) hasStep(stepName string) bool <span class="cov0" title="0">{
        for _, step := range p.Steps </span><span class="cov0" title="0">{
                if step.Name == stepName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetStep returns a step by name
func (p *Pipeline) GetStep(stepName string) (PipelineStep, bool) <span class="cov0" title="0">{
        for _, step := range p.Steps </span><span class="cov0" title="0">{
                if step.Name == stepName </span><span class="cov0" title="0">{
                        return step, true
                }</span>
        }
        <span class="cov0" title="0">return PipelineStep{}, false</span>
}

// IsScheduled returns true if the pipeline has a schedule
func (p *Pipeline) IsScheduled() bool <span class="cov0" title="0">{
        return p.Schedule != nil &amp;&amp; p.Schedule.IsEnabled
}</span>

// CanExecute returns true if the pipeline can be executed
func (p *Pipeline) CanExecute() bool <span class="cov4" title="5">{
        return p.Status == PipelineStatusActive &amp;&amp; len(p.Steps) &gt; 0
}</span>

// Validate validates the pipeline
func (p *Pipeline) Validate() result.Result[bool] <span class="cov4" title="4">{
        if p.Name == "" </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("name is required"))
        }</span>

        <span class="cov3" title="3">if p.Owner == "" </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("owner is required"))
        }</span>

        <span class="cov2" title="2">if len(p.Steps) == 0 </span><span class="cov1" title="1">{
                return result.Failure[bool](errors.ValidationError("at least one step is required"))
        }</span>

        <span class="cov1" title="1">return result.Success(true)</span>
}

// HasTag checks if the pipeline has a specific tag
func (p *Pipeline) HasTag(tag string) bool <span class="cov3" title="3">{
        for _, t := range p.Tags </span><span class="cov4" title="5">{
                if t == tag </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">// Package entities contains domain events for pipeline operations
package entities

import (
        "time"

        "github.com/flext/flexcore/domain"
)

// PipelineCreatedEvent is raised when a pipeline is created
type PipelineCreatedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
        Owner        string
}

// NewPipelineCreatedEvent creates a new pipeline created event
func NewPipelineCreatedEvent(pipelineID PipelineID, name, owner string) PipelineCreatedEvent <span class="cov10" title="13">{
        return PipelineCreatedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineCreated", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
                Owner:           owner,
        }
}</span>

// PipelineActivatedEvent is raised when a pipeline is activated
type PipelineActivatedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
}

// NewPipelineActivatedEvent creates a new pipeline activated event
func NewPipelineActivatedEvent(pipelineID PipelineID, name string) PipelineActivatedEvent <span class="cov7" title="6">{
        return PipelineActivatedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineActivated", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
        }
}</span>

// PipelineDeactivatedEvent is raised when a pipeline is deactivated
type PipelineDeactivatedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
}

// NewPipelineDeactivatedEvent creates a new pipeline deactivated event
func NewPipelineDeactivatedEvent(pipelineID PipelineID, name string) PipelineDeactivatedEvent <span class="cov1" title="1">{
        return PipelineDeactivatedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineDeactivated", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
        }
}</span>

// PipelineStartedEvent is raised when a pipeline starts execution
type PipelineStartedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
        StartedAt    time.Time
}

// NewPipelineStartedEvent creates a new pipeline started event
func NewPipelineStartedEvent(pipelineID PipelineID, name string, startedAt time.Time) PipelineStartedEvent <span class="cov5" title="4">{
        return PipelineStartedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineStarted", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
                StartedAt:       startedAt,
        }
}</span>

// PipelineCompletedEvent is raised when a pipeline completes successfully
type PipelineCompletedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
        CompletedAt  time.Time
}

// NewPipelineCompletedEvent creates a new pipeline completed event
func NewPipelineCompletedEvent(pipelineID PipelineID, name string, completedAt time.Time) PipelineCompletedEvent <span class="cov1" title="1">{
        return PipelineCompletedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineCompleted", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
                CompletedAt:     completedAt,
        }
}</span>

// PipelineFailedEvent is raised when a pipeline fails
type PipelineFailedEvent struct {
        domain.BaseDomainEvent
        PipelineID   PipelineID
        PipelineName string
        Reason       string
        FailedAt     time.Time
}

// NewPipelineFailedEvent creates a new pipeline failed event
func NewPipelineFailedEvent(pipelineID PipelineID, name, reason string, failedAt time.Time) PipelineFailedEvent <span class="cov1" title="1">{
        return PipelineFailedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineFailed", pipelineID.String()),
                PipelineID:      pipelineID,
                PipelineName:    name,
                Reason:          reason,
                FailedAt:        failedAt,
        }
}</span>

// PipelineStepAddedEvent is raised when a step is added to a pipeline
type PipelineStepAddedEvent struct {
        domain.BaseDomainEvent
        PipelineID PipelineID
        StepID     string
        StepName   string
}

// NewPipelineStepAddedEvent creates a new pipeline step added event
func NewPipelineStepAddedEvent(pipelineID PipelineID, stepID, stepName string) PipelineStepAddedEvent <span class="cov9" title="10">{
        return PipelineStepAddedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineStepAdded", pipelineID.String()),
                PipelineID:      pipelineID,
                StepID:          stepID,
                StepName:        stepName,
        }
}</span>

// PipelineStepRemovedEvent is raised when a step is removed from a pipeline
type PipelineStepRemovedEvent struct {
        domain.BaseDomainEvent
        PipelineID PipelineID
        StepName   string
}

// NewPipelineStepRemovedEvent creates a new pipeline step removed event
func NewPipelineStepRemovedEvent(pipelineID PipelineID, stepName string) PipelineStepRemovedEvent <span class="cov3" title="2">{
        return PipelineStepRemovedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineStepRemoved", pipelineID.String()),
                PipelineID:      pipelineID,
                StepName:        stepName,
        }
}</span>

// PipelineScheduleSetEvent is raised when a pipeline schedule is set
type PipelineScheduleSetEvent struct {
        domain.BaseDomainEvent
        PipelineID     PipelineID
        CronExpression string
        Timezone       string
}

// NewPipelineScheduleSetEvent creates a new pipeline schedule set event
func NewPipelineScheduleSetEvent(pipelineID PipelineID, cronExpression, timezone string) PipelineScheduleSetEvent <span class="cov1" title="1">{
        return PipelineScheduleSetEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineScheduleSet", pipelineID.String()),
                PipelineID:      pipelineID,
                CronExpression:  cronExpression,
                Timezone:        timezone,
        }
}</span>

// PipelineScheduleClearedEvent is raised when a pipeline schedule is cleared
type PipelineScheduleClearedEvent struct {
        domain.BaseDomainEvent
        PipelineID PipelineID
}

// NewPipelineScheduleClearedEvent creates a new pipeline schedule cleared event
func NewPipelineScheduleClearedEvent(pipelineID PipelineID) PipelineScheduleClearedEvent <span class="cov1" title="1">{
        return PipelineScheduleClearedEvent{
                BaseDomainEvent: domain.NewBaseDomainEvent("PipelineScheduleCleared", pipelineID.String()),
                PipelineID:      pipelineID,
        }
}</pre>
		
		<pre class="file" id="file9" style="display: none">// Package entities contains domain entities for FlexCore
package entities

import (
        "time"

        "github.com/flext/flexcore/domain"
        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
        "github.com/google/uuid"
)

// PluginID represents a unique plugin identifier
type PluginID string

// NewPluginID creates a new plugin ID
func NewPluginID() PluginID <span class="cov0" title="0">{
        return PluginID(uuid.New().String())
}</span>

// String returns the string representation of the plugin ID
func (id PluginID) String() string <span class="cov0" title="0">{
        return string(id)
}</span>

// PluginType represents the type of plugin
type PluginType int

const (
        PluginTypeExtractor PluginType = iota
        PluginTypeTransformer
        PluginTypeLoader
        PluginTypeProcessor
)

// String returns the string representation of the plugin type
func (t PluginType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case PluginTypeExtractor:<span class="cov0" title="0">
                return "extractor"</span>
        case PluginTypeTransformer:<span class="cov0" title="0">
                return "transformer"</span>
        case PluginTypeLoader:<span class="cov0" title="0">
                return "loader"</span>
        case PluginTypeProcessor:<span class="cov0" title="0">
                return "processor"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// PluginStatus represents the status of a plugin
type PluginStatus int

const (
        PluginStatusRegistered PluginStatus = iota
        PluginStatusActive
        PluginStatusInactive
        PluginStatusError
)

// String returns the string representation of the plugin status
func (s PluginStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case PluginStatusRegistered:<span class="cov0" title="0">
                return "registered"</span>
        case PluginStatusActive:<span class="cov0" title="0">
                return "active"</span>
        case PluginStatusInactive:<span class="cov0" title="0">
                return "inactive"</span>
        case PluginStatusError:<span class="cov0" title="0">
                return "error"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Plugin represents a plugin in the domain
type Plugin struct {
        id          PluginID
        name        string
        version     string
        description string
        pluginType  PluginType
        status      PluginStatus
        config      map[string]interface{}
        capabilities []string
        createdAt   time.Time
        updatedAt   time.Time
        events      []domain.DomainEvent
}

// NewPlugin creates a new plugin
func NewPlugin(name, version, description string, pluginType PluginType) result.Result[*Plugin] <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return result.Failure[*Plugin](errors.ValidationError("plugin name is required"))
        }</span>

        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                return result.Failure[*Plugin](errors.ValidationError("plugin version is required"))
        }</span>

        <span class="cov0" title="0">now := time.Now()
        plugin := &amp;Plugin{
                id:          NewPluginID(),
                name:        name,
                version:     version,
                description: description,
                pluginType:  pluginType,
                status:      PluginStatusRegistered,
                config:      make(map[string]interface{}),
                capabilities: make([]string, 0),
                createdAt:   now,
                updatedAt:   now,
                events:      make([]domain.DomainEvent, 0),
        }

        // Add domain event
        event := domain.CreatePluginEvent("PluginCreated", plugin.id.String(), map[string]interface{}{
                "plugin_id":  plugin.id.String(),
                "name":       plugin.name,
                "version":    plugin.version,
                "type":       plugin.pluginType.String(),
                "created_at": plugin.createdAt,
        })
        plugin.addEvent(event)

        return result.Success(plugin)</span>
}

// ID returns the plugin ID
func (p *Plugin) ID() PluginID <span class="cov0" title="0">{
        return p.id
}</span>

// Name returns the plugin name
func (p *Plugin) Name() string <span class="cov0" title="0">{
        return p.name
}</span>

// Version returns the plugin version
func (p *Plugin) Version() string <span class="cov0" title="0">{
        return p.version
}</span>

// Description returns the plugin description
func (p *Plugin) Description() string <span class="cov0" title="0">{
        return p.description
}</span>

// Type returns the plugin type
func (p *Plugin) Type() PluginType <span class="cov0" title="0">{
        return p.pluginType
}</span>

// Status returns the plugin status
func (p *Plugin) Status() PluginStatus <span class="cov0" title="0">{
        return p.status
}</span>

// Config returns the plugin configuration
func (p *Plugin) Config() map[string]interface{} <span class="cov0" title="0">{
        // Return a copy to prevent modification
        config := make(map[string]interface{})
        for k, v := range p.config </span><span class="cov0" title="0">{
                config[k] = v
        }</span>
        <span class="cov0" title="0">return config</span>
}

// Capabilities returns the plugin capabilities
func (p *Plugin) Capabilities() []string <span class="cov0" title="0">{
        // Return a copy to prevent modification
        capabilities := make([]string, len(p.capabilities))
        copy(capabilities, p.capabilities)
        return capabilities
}</span>

// CreatedAt returns the creation time
func (p *Plugin) CreatedAt() time.Time <span class="cov0" title="0">{
        return p.createdAt
}</span>

// UpdatedAt returns the last update time
func (p *Plugin) UpdatedAt() time.Time <span class="cov0" title="0">{
        return p.updatedAt
}</span>

// Activate activates the plugin
func (p *Plugin) Activate() result.Result[bool] <span class="cov0" title="0">{
        if p.status == PluginStatusActive </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("plugin is already active"))
        }</span>

        <span class="cov0" title="0">if p.status == PluginStatusError </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("cannot activate plugin in error status"))
        }</span>

        <span class="cov0" title="0">p.status = PluginStatusActive
        p.updatedAt = time.Now()

        // Add domain event
        event := domain.CreatePluginEvent("PluginActivated", p.id.String(), map[string]interface{}{
                "plugin_id":    p.id.String(),
                "name":         p.name,
                "activated_at": p.updatedAt,
        })
        p.addEvent(event)

        return result.Success(true)</span>
}

// Deactivate deactivates the plugin
func (p *Plugin) Deactivate() result.Result[bool] <span class="cov0" title="0">{
        if p.status == PluginStatusInactive </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("plugin is already inactive"))
        }</span>

        <span class="cov0" title="0">p.status = PluginStatusInactive
        p.updatedAt = time.Now()

        // Add domain event
        event := domain.CreatePluginEvent("PluginDeactivated", p.id.String(), map[string]interface{}{
                "plugin_id":      p.id.String(),
                "name":           p.name,
                "deactivated_at": p.updatedAt,
        })
        p.addEvent(event)

        return result.Success(true)</span>
}

// SetError sets the plugin to error status
func (p *Plugin) SetError(errorMessage string) <span class="cov0" title="0">{
        p.status = PluginStatusError
        p.updatedAt = time.Now()

        // Add domain event
        event := domain.CreatePluginEvent("PluginError", p.id.String(), map[string]interface{}{
                "plugin_id": p.id.String(),
                "name":      p.name,
                "error":     errorMessage,
                "error_at":  p.updatedAt,
        })
        p.addEvent(event)
}</span>

// UpdateConfig updates the plugin configuration
func (p *Plugin) UpdateConfig(config map[string]interface{}) result.Result[bool] <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("config cannot be nil"))
        }</span>

        <span class="cov0" title="0">p.config = make(map[string]interface{})
        for k, v := range config </span><span class="cov0" title="0">{
                p.config[k] = v
        }</span>
        <span class="cov0" title="0">p.updatedAt = time.Now()

        // Add domain event
        event := domain.CreatePluginEvent("PluginConfigUpdated", p.id.String(), map[string]interface{}{
                "plugin_id":  p.id.String(),
                "name":       p.name,
                "updated_at": p.updatedAt,
        })
        p.addEvent(event)

        return result.Success(true)</span>
}

// AddCapability adds a capability to the plugin
func (p *Plugin) AddCapability(capability string) result.Result[bool] <span class="cov0" title="0">{
        if capability == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("capability cannot be empty"))
        }</span>

        // Check if capability already exists
        <span class="cov0" title="0">for _, existing := range p.capabilities </span><span class="cov0" title="0">{
                if existing == capability </span><span class="cov0" title="0">{
                        return result.Failure[bool](errors.ValidationError("capability already exists"))
                }</span>
        }

        <span class="cov0" title="0">p.capabilities = append(p.capabilities, capability)
        p.updatedAt = time.Now()

        return result.Success(true)</span>
}

// RemoveCapability removes a capability from the plugin
func (p *Plugin) RemoveCapability(capability string) result.Result[bool] <span class="cov0" title="0">{
        for i, existing := range p.capabilities </span><span class="cov0" title="0">{
                if existing == capability </span><span class="cov0" title="0">{
                        p.capabilities = append(p.capabilities[:i], p.capabilities[i+1:]...)
                        p.updatedAt = time.Now()
                        return result.Success(true)
                }</span>
        }

        <span class="cov0" title="0">return result.Failure[bool](errors.ValidationError("capability not found"))</span>
}

// HasCapability checks if the plugin has a specific capability
func (p *Plugin) HasCapability(capability string) bool <span class="cov0" title="0">{
        for _, existing := range p.capabilities </span><span class="cov0" title="0">{
                if existing == capability </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetEvents returns the domain events
func (p *Plugin) GetEvents() []domain.DomainEvent <span class="cov0" title="0">{
        return p.events
}</span>

// ClearEvents clears the domain events
func (p *Plugin) ClearEvents() <span class="cov0" title="0">{
        p.events = make([]domain.DomainEvent, 0)
}</span>

// addEvent adds a domain event
func (p *Plugin) addEvent(event domain.DomainEvent) <span class="cov0" title="0">{
        p.events = append(p.events, event)
}</span>

// IsCompatibleWith checks if this plugin is compatible with another plugin
func (p *Plugin) IsCompatibleWith(other *Plugin) bool <span class="cov0" title="0">{
        // Basic compatibility check based on types
        switch p.pluginType </span>{
        case PluginTypeExtractor:<span class="cov0" title="0">
                return other.pluginType == PluginTypeTransformer || other.pluginType == PluginTypeLoader</span>
        case PluginTypeTransformer:<span class="cov0" title="0">
                return other.pluginType == PluginTypeLoader || other.pluginType == PluginTypeTransformer</span>
        case PluginTypeLoader:<span class="cov0" title="0">
                return false</span> // Loaders are typically endpoints
        case PluginTypeProcessor:<span class="cov0" title="0">
                return true</span> // Processors can work with any type
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// Validate validates the plugin state
func (p *Plugin) Validate() result.Result[bool] <span class="cov0" title="0">{
        if p.id == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("plugin ID is required"))
        }</span>

        <span class="cov0" title="0">if p.name == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("plugin name is required"))
        }</span>

        <span class="cov0" title="0">if p.version == "" </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("plugin version is required"))
        }</span>

        <span class="cov0" title="0">if p.createdAt.IsZero() </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("created at time is required"))
        }</span>

        <span class="cov0" title="0">if p.updatedAt.IsZero() </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("updated at time is required"))
        }</span>

        <span class="cov0" title="0">return result.Success(true)</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">// Package main demonstrates how to create a FlexCore plugin using HashiCorp go-plugin
package main

import (
        "context"
        "log"
        "net/rpc"
        "strings"
        "time"

        "github.com/flext/flexcore/pkg/adapter"
        "github.com/hashicorp/go-plugin"
)

// SimpleAdapter is a basic adapter implementation
type SimpleAdapter struct {
        config map[string]interface{}
}

func (a *SimpleAdapter) Name() string <span class="cov0" title="0">{
        return "simple-adapter"
}</span>

func (a *SimpleAdapter) Version() string <span class="cov0" title="0">{
        return "1.0.0"
}</span>

func (a *SimpleAdapter) Configure(config map[string]interface{}) error <span class="cov0" title="0">{
        a.config = config
        log.Printf("Configured with: %+v", config)
        return nil
}</span>

func (a *SimpleAdapter) Extract(ctx context.Context, req adapter.ExtractRequest) (*adapter.ExtractResponse, error) <span class="cov0" title="0">{
        log.Printf("Extract called with source: %s", req.Source)
        
        // Simulate some data extraction
        records := []adapter.Record{
                {
                        ID: "1",
                        Data: map[string]interface{}{
                                "name":  "John Doe",
                                "email": "john@example.com",
                                "age":   30,
                        },
                        Timestamp: time.Now(),
                },
                {
                        ID: "2",
                        Data: map[string]interface{}{
                                "name":  "Jane Smith",
                                "email": "jane@example.com",
                                "age":   25,
                        },
                        Timestamp: time.Now(),
                },
        }

        return &amp;adapter.ExtractResponse{
                Records:     records,
                HasMore:     false,
                ExtractedAt: time.Now(),
        }, nil
}</span>

func (a *SimpleAdapter) Load(ctx context.Context, req adapter.LoadRequest) (*adapter.LoadResponse, error) <span class="cov0" title="0">{
        log.Printf("Load called with target: %s, records: %d", req.Target, len(req.Records))
        
        // Simulate loading data
        return &amp;adapter.LoadResponse{
                RecordsLoaded: int64(len(req.Records)),
                RecordsFailed: 0,
                LoadedAt:      time.Now(),
        }, nil
}</span>

func (a *SimpleAdapter) Transform(ctx context.Context, req adapter.TransformRequest) (*adapter.TransformResponse, error) <span class="cov0" title="0">{
        log.Printf("Transform called with %d records", len(req.Records))
        
        // Simple transformation: uppercase all string values
        transformed := make([]adapter.Record, len(req.Records))
        
        for i, record := range req.Records </span><span class="cov0" title="0">{
                newData := make(map[string]interface{})
                for k, v := range record.Data </span><span class="cov0" title="0">{
                        if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                newData[k] = strings.ToUpper(str)
                        }</span> else<span class="cov0" title="0"> {
                                newData[k] = v
                        }</span>
                }
                
                <span class="cov0" title="0">transformed[i] = adapter.Record{
                        ID:        record.ID,
                        Data:      newData,
                        Timestamp: time.Now(),
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;adapter.TransformResponse{
                Records:            transformed,
                RecordsTransformed: int64(len(transformed)),
                RecordsFailed:      0,
                TransformedAt:      time.Now(),
        }, nil</span>
}

func (a *SimpleAdapter) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Always healthy in this simple example
        return nil
}</span>

// AdapterPlugin is the implementation of plugin.Plugin for our adapter
type AdapterPlugin struct {
        Impl adapter.Adapter
}

func (p *AdapterPlugin) Server(*plugin.MuxBroker) (interface{}, error) <span class="cov0" title="0">{
        return &amp;AdapterRPCServer{Impl: p.Impl}, nil
}</span>

func (p *AdapterPlugin) Client(b *plugin.MuxBroker, c *rpc.Client) (interface{}, error) <span class="cov0" title="0">{
        return &amp;AdapterRPCClient{client: c}, nil
}</span>

// AdapterRPCServer is the RPC server that AdapterRPC talks to
type AdapterRPCServer struct {
        Impl adapter.Adapter
}

func (s *AdapterRPCServer) Name(args interface{}, resp *string) error <span class="cov0" title="0">{
        *resp = s.Impl.Name()
        return nil
}</span>

func (s *AdapterRPCServer) Version(args interface{}, resp *string) error <span class="cov0" title="0">{
        *resp = s.Impl.Version()
        return nil
}</span>

func (s *AdapterRPCServer) Configure(args map[string]interface{}, resp *interface{}) error <span class="cov0" title="0">{
        return s.Impl.Configure(args)
}</span>

func (s *AdapterRPCServer) Extract(args adapter.ExtractRequest, resp *adapter.ExtractResponse) error <span class="cov0" title="0">{
        result, err := s.Impl.Extract(context.Background(), args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*resp = *result
        return nil</span>
}

func (s *AdapterRPCServer) Load(args adapter.LoadRequest, resp *adapter.LoadResponse) error <span class="cov0" title="0">{
        result, err := s.Impl.Load(context.Background(), args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*resp = *result
        return nil</span>
}

func (s *AdapterRPCServer) Transform(args adapter.TransformRequest, resp *adapter.TransformResponse) error <span class="cov0" title="0">{
        result, err := s.Impl.Transform(context.Background(), args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*resp = *result
        return nil</span>
}

func (s *AdapterRPCServer) HealthCheck(args interface{}, resp *interface{}) error <span class="cov0" title="0">{
        return s.Impl.HealthCheck(context.Background())
}</span>

// AdapterRPCClient is an implementation that talks over RPC
type AdapterRPCClient struct {
        client *rpc.Client
}

func (c *AdapterRPCClient) Name() string <span class="cov0" title="0">{
        var resp string
        c.client.Call("Plugin.Name", new(interface{}), &amp;resp)
        return resp
}</span>

func (c *AdapterRPCClient) Version() string <span class="cov0" title="0">{
        var resp string
        c.client.Call("Plugin.Version", new(interface{}), &amp;resp)
        return resp
}</span>

func (c *AdapterRPCClient) Configure(config map[string]interface{}) error <span class="cov0" title="0">{
        var resp interface{}
        return c.client.Call("Plugin.Configure", config, &amp;resp)
}</span>

func (c *AdapterRPCClient) Extract(ctx context.Context, req adapter.ExtractRequest) (*adapter.ExtractResponse, error) <span class="cov0" title="0">{
        var resp adapter.ExtractResponse
        err := c.client.Call("Plugin.Extract", req, &amp;resp)
        return &amp;resp, err
}</span>

func (c *AdapterRPCClient) Load(ctx context.Context, req adapter.LoadRequest) (*adapter.LoadResponse, error) <span class="cov0" title="0">{
        var resp adapter.LoadResponse
        err := c.client.Call("Plugin.Load", req, &amp;resp)
        return &amp;resp, err
}</span>

func (c *AdapterRPCClient) Transform(ctx context.Context, req adapter.TransformRequest) (*adapter.TransformResponse, error) <span class="cov0" title="0">{
        var resp adapter.TransformResponse
        err := c.client.Call("Plugin.Transform", req, &amp;resp)
        return &amp;resp, err
}</span>

func (c *AdapterRPCClient) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        var resp interface{}
        return c.client.Call("Plugin.HealthCheck", new(interface{}), &amp;resp)
}</span>

// Handshake is a common handshake that is shared by plugin and host
var Handshake = plugin.HandshakeConfig{
        ProtocolVersion:  1,
        MagicCookieKey:   "FLEXCORE_PLUGIN",
        MagicCookieValue: "flexcore-adapter-v1",
}

// pluginMap is the map of plugins we can dispense
var pluginMap = map[string]plugin.Plugin{
        "adapter": &amp;AdapterPlugin{},
}

func main() <span class="cov0" title="0">{
        // Create adapter instance
        adapter := &amp;SimpleAdapter{}

        // Serve the plugin
        plugin.Serve(&amp;plugin.ServeConfig{
                HandshakeConfig: Handshake,
                Plugins: map[string]plugin.Plugin{
                        "adapter": &amp;AdapterPlugin{Impl: adapter},
                },
                
                // A non-nil value here enables gRPC serving for this plugin
                GRPCServer: plugin.DefaultGRPCServer,
                
                // If set, the plugin will exit gracefully after this timeout
                // if it doesn't receive any connections
                // Timeout: 30 * time.Second, // Removed - not supported in current go-plugin version
        })
}</pre>
		
		<pre class="file" id="file11" style="display: none">// Package config provides advanced configuration management using Viper
package config

import (
        "strings"
        "sync"
        "time"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/patterns"
        "github.com/flext/flexcore/shared/result"
        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

// Manager provides configuration management with hot-reloading
type Manager struct {
        viper         *viper.Viper
        mu            sync.RWMutex
        watchers      []ConfigWatcher
        validators    []ConfigValidator
        configFile    string
        configType    string
        envPrefix     string
        remoteConfig  *RemoteConfig
}

// ConfigWatcher is called when configuration changes
type ConfigWatcher func(oldConfig, newConfig interface{})

// ConfigValidator validates configuration
type ConfigValidator func(config interface{}) error

// RemoteConfig represents remote configuration settings
type RemoteConfig struct {
        Provider string // consul, etcd, firestore
        Endpoint string
        Path     string
        SecretKeyring string
}

// NewManager creates a new configuration manager
func NewManager(options ...patterns.Option[Manager]) result.Result[*Manager] <span class="cov0" title="0">{
        manager := &amp;Manager{
                viper:      viper.New(),
                watchers:   make([]ConfigWatcher, 0),
                validators: make([]ConfigValidator, 0),
                configType: "yaml",
                envPrefix:  "FLEXCORE",
        }

        if err := patterns.Apply(manager, options...); err != nil </span><span class="cov0" title="0">{
                return result.Failure[*Manager](errors.Wrap(err, "failed to apply options"))
        }</span>

        // Configure viper
        <span class="cov0" title="0">manager.viper.SetConfigType(manager.configType)
        manager.viper.SetEnvPrefix(manager.envPrefix)
        manager.viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        manager.viper.AutomaticEnv()

        // Set config file if provided
        if manager.configFile != "" </span><span class="cov0" title="0">{
                manager.viper.SetConfigFile(manager.configFile)
        }</span>

        // Setup remote config if provided
        <span class="cov0" title="0">if manager.remoteConfig != nil </span><span class="cov0" title="0">{
                if err := manager.setupRemoteConfig(); err != nil </span><span class="cov0" title="0">{
                        return result.Failure[*Manager](err)
                }</span>
        }

        <span class="cov0" title="0">return result.Success(manager)</span>
}

// Config file option
func WithConfigFile(path string) patterns.Option[Manager] <span class="cov0" title="0">{
        return func(m *Manager) error </span><span class="cov0" title="0">{
                m.configFile = path
                return nil
        }</span>
}

// Config type option
func WithConfigType(configType string) patterns.Option[Manager] <span class="cov0" title="0">{
        return func(m *Manager) error </span><span class="cov0" title="0">{
                m.configType = configType
                return nil
        }</span>
}

// Environment prefix option
func WithEnvPrefix(prefix string) patterns.Option[Manager] <span class="cov0" title="0">{
        return func(m *Manager) error </span><span class="cov0" title="0">{
                m.envPrefix = prefix
                return nil
        }</span>
}

// Remote config option
func WithRemoteConfig(config *RemoteConfig) patterns.Option[Manager] <span class="cov0" title="0">{
        return func(m *Manager) error </span><span class="cov0" title="0">{
                m.remoteConfig = config
                return nil
        }</span>
}

// Load loads configuration from all sources
func (m *Manager) Load() error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Load from file if exists
        if m.configFile != "" </span><span class="cov0" title="0">{
                if err := m.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to read config file")
                        }</span>
                }
        }

        // Load from remote if configured
        <span class="cov0" title="0">if m.remoteConfig != nil </span><span class="cov0" title="0">{
                if err := m.viper.ReadRemoteConfig(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to read remote config")
                }</span>
        }

        // Validate configuration
        <span class="cov0" title="0">if err := m.validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WatchConfig enables hot-reloading of configuration
func (m *Manager) WatchConfig() error <span class="cov0" title="0">{
        if m.configFile == "" </span><span class="cov0" title="0">{
                return errors.ValidationError("no config file to watch")
        }</span>

        <span class="cov0" title="0">m.viper.WatchConfig()
        m.viper.OnConfigChange(func(e fsnotify.Event) </span><span class="cov0" title="0">{
                m.handleConfigChange()
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

// WatchRemoteConfig watches remote configuration for changes
func (m *Manager) WatchRemoteConfig(interval time.Duration) error <span class="cov0" title="0">{
        if m.remoteConfig == nil </span><span class="cov0" title="0">{
                return errors.ValidationError("no remote config to watch")
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        if err := m.viper.WatchRemoteConfig(); err != nil </span>{<span class="cov0" title="0">
                                // Log error but continue watching
                        }</span>
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a value by key
func (m *Manager) Get(key string) interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.Get(key)
}</span>

// GetString retrieves a string value
func (m *Manager) GetString(key string) string <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetString(key)
}</span>

// GetInt retrieves an int value
func (m *Manager) GetInt(key string) int <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetInt(key)
}</span>

// GetBool retrieves a bool value
func (m *Manager) GetBool(key string) bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetBool(key)
}</span>

// GetDuration retrieves a duration value
func (m *Manager) GetDuration(key string) time.Duration <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetDuration(key)
}</span>

// GetStringSlice retrieves a string slice
func (m *Manager) GetStringSlice(key string) []string <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetStringSlice(key)
}</span>

// GetStringMap retrieves a string map
func (m *Manager) GetStringMap(key string) map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.GetStringMap(key)
}</span>

// Unmarshal unmarshals configuration into a struct
func (m *Manager) Unmarshal(rawVal interface{}, opts ...viper.DecoderConfigOption) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.Unmarshal(rawVal, opts...)
}</span>

// UnmarshalKey unmarshals a specific key into a struct
func (m *Manager) UnmarshalKey(key string, rawVal interface{}, opts ...viper.DecoderConfigOption) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.UnmarshalKey(key, rawVal, opts...)
}</span>

// Set sets a value for a key
func (m *Manager) Set(key string, value interface{}) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.viper.Set(key, value)
}</span>

// SetDefault sets a default value for a key
func (m *Manager) SetDefault(key string, value interface{}) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.viper.SetDefault(key, value)
}</span>

// IsSet checks if a key is set
func (m *Manager) IsSet(key string) bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.IsSet(key)
}</span>

// AllKeys returns all configuration keys
func (m *Manager) AllKeys() []string <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.AllKeys()
}</span>

// AllSettings returns all settings as a map
func (m *Manager) AllSettings() map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.viper.AllSettings()
}</span>

// AddWatcher adds a configuration change watcher
func (m *Manager) AddWatcher(watcher ConfigWatcher) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.watchers = append(m.watchers, watcher)
}</span>

// AddValidator adds a configuration validator
func (m *Manager) AddValidator(validator ConfigValidator) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.validators = append(m.validators, validator)
}</span>

// validate runs all validators
func (m *Manager) validate() error <span class="cov0" title="0">{
        config := m.viper.AllSettings()
        
        for _, validator := range m.validators </span><span class="cov0" title="0">{
                if err := validator(config); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "config validation failed")
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// handleConfigChange handles configuration changes
func (m *Manager) handleConfigChange() <span class="cov0" title="0">{
        m.mu.RLock()
        oldConfig := m.viper.AllSettings()
        m.mu.RUnlock()

        // Re-validate configuration
        if err := m.validate(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't crash
                return
        }</span>

        <span class="cov0" title="0">m.mu.RLock()
        newConfig := m.viper.AllSettings()
        watchers := make([]ConfigWatcher, len(m.watchers))
        copy(watchers, m.watchers)
        m.mu.RUnlock()

        // Notify watchers
        for _, watcher := range watchers </span><span class="cov0" title="0">{
                watcher(oldConfig, newConfig)
        }</span>
}

// setupRemoteConfig configures remote configuration provider
func (m *Manager) setupRemoteConfig() error <span class="cov0" title="0">{
        if m.remoteConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var err error
        switch m.remoteConfig.Provider </span>{
        case "consul":<span class="cov0" title="0">
                err = m.viper.AddRemoteProvider("consul", m.remoteConfig.Endpoint, m.remoteConfig.Path)</span>
        case "etcd":<span class="cov0" title="0">
                err = m.viper.AddRemoteProvider("etcd", m.remoteConfig.Endpoint, m.remoteConfig.Path)</span>
        case "firestore":<span class="cov0" title="0">
                err = m.viper.AddRemoteProvider("firestore", m.remoteConfig.Endpoint, m.remoteConfig.Path)</span>
        default:<span class="cov0" title="0">
                return errors.ValidationError("unsupported remote provider: " + m.remoteConfig.Provider)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to add remote provider")
        }</span>

        <span class="cov0" title="0">if m.remoteConfig.SecretKeyring != "" </span><span class="cov0" title="0">{
                m.viper.SetConfigType("json")
                if err := m.viper.AddSecureRemoteProvider(
                        m.remoteConfig.Provider,
                        m.remoteConfig.Endpoint,
                        m.remoteConfig.Path,
                        m.remoteConfig.SecretKeyring,
                ); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to add secure remote provider")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ConfigBuilder provides a fluent interface for building configurations
type ConfigBuilder struct {
        manager *Manager
        config  map[string]interface{}
}

// NewConfigBuilder creates a new configuration builder
func NewConfigBuilder(manager *Manager) *ConfigBuilder <span class="cov0" title="0">{
        return &amp;ConfigBuilder{
                manager: manager,
                config:  make(map[string]interface{}),
        }
}</span>

// With adds a key-value pair
func (b *ConfigBuilder) With(key string, value interface{}) *ConfigBuilder <span class="cov0" title="0">{
        b.config[key] = value
        return b
}</span>

// WithDefaults adds multiple default values
func (b *ConfigBuilder) WithDefaults(defaults map[string]interface{}) *ConfigBuilder <span class="cov0" title="0">{
        for k, v := range defaults </span><span class="cov0" title="0">{
                b.manager.SetDefault(k, v)
        }</span>
        <span class="cov0" title="0">return b</span>
}

// FromFile loads configuration from a file
func (b *ConfigBuilder) FromFile(path string) *ConfigBuilder <span class="cov0" title="0">{
        b.manager.configFile = path
        b.manager.viper.SetConfigFile(path)
        return b
}</span>

// FromEnv enables environment variable loading
func (b *ConfigBuilder) FromEnv(prefix string) *ConfigBuilder <span class="cov0" title="0">{
        b.manager.envPrefix = prefix
        b.manager.viper.SetEnvPrefix(prefix)
        b.manager.viper.AutomaticEnv()
        return b
}</span>

// Build applies the configuration
func (b *ConfigBuilder) Build() error <span class="cov0" title="0">{
        for k, v := range b.config </span><span class="cov0" title="0">{
                b.manager.Set(k, v)
        }</span>
        <span class="cov0" title="0">return b.manager.Load()</span>
}

// Typed configuration wrapper
type TypedConfig[T any] struct {
        manager *Manager
        key     string
}

// NewTypedConfig creates a typed configuration wrapper
func NewTypedConfig[T any](manager *Manager, key string) *TypedConfig[T] <span class="cov0" title="0">{
        return &amp;TypedConfig[T]{
                manager: manager,
                key:     key,
        }
}</span>

// Get retrieves the typed configuration
func (tc *TypedConfig[T]) Get() result.Result[T] <span class="cov0" title="0">{
        var config T
        if err := tc.manager.UnmarshalKey(tc.key, &amp;config); err != nil </span><span class="cov0" title="0">{
                return result.Failure[T](errors.Wrap(err, "failed to unmarshal config"))
        }</span>
        <span class="cov0" title="0">return result.Success(config)</span>
}

// Watch watches for configuration changes
func (tc *TypedConfig[T]) Watch(handler func(old, new T)) <span class="cov0" title="0">{
        tc.manager.AddWatcher(func(oldConfig, newConfig interface{}) </span><span class="cov0" title="0">{
                var oldTyped, newTyped T
                
                // Extract old config
                if oldMap, ok := oldConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if oldValue, exists := oldMap[tc.key]; exists </span><span class="cov0" title="0">{
                                // Simple type assertion - in production use proper unmarshaling
                                if typed, ok := oldValue.(T); ok </span><span class="cov0" title="0">{
                                        oldTyped = typed
                                }</span>
                        }
                }
                
                // Extract new config
                <span class="cov0" title="0">if newMap, ok := newConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if newValue, exists := newMap[tc.key]; exists </span><span class="cov0" title="0">{
                                // Simple type assertion - in production use proper unmarshaling
                                if typed, ok := newValue.(T); ok </span><span class="cov0" title="0">{
                                        newTyped = typed
                                }</span>
                        }
                }
                
                <span class="cov0" title="0">handler(oldTyped, newTyped)</span>
        })
}

// Common configuration structures

// DatabaseConfig represents database configuration
type DatabaseConfig struct {
        Driver          string        `mapstructure:"driver"`
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        Database        string        `mapstructure:"database"`
        Username        string        `mapstructure:"username"`
        Password        string        `mapstructure:"password"`
        SSLMode         string        `mapstructure:"ssl_mode"`
        MaxOpenConns    int           `mapstructure:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

// ServerConfig represents server configuration
type ServerConfig struct {
        Host            string        `mapstructure:"host"`
        Port            int           `mapstructure:"port"`
        ReadTimeout     time.Duration `mapstructure:"read_timeout"`
        WriteTimeout    time.Duration `mapstructure:"write_timeout"`
        ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout"`
        TLS             *TLSConfig    `mapstructure:"tls"`
}

// TLSConfig represents TLS configuration
type TLSConfig struct {
        Enabled  bool   `mapstructure:"enabled"`
        CertFile string `mapstructure:"cert_file"`
        KeyFile  string `mapstructure:"key_file"`
}

// LogConfig represents logging configuration
type LogConfig struct {
        Level      string `mapstructure:"level"`
        Format     string `mapstructure:"format"`
        Output     string `mapstructure:"output"`
        File       string `mapstructure:"file"`
        MaxSize    int    `mapstructure:"max_size"`
        MaxBackups int    `mapstructure:"max_backups"`
        MaxAge     int    `mapstructure:"max_age"`
}

// GetDatabaseConfig retrieves database configuration
func (m *Manager) GetDatabaseConfig() result.Result[DatabaseConfig] <span class="cov0" title="0">{
        var config DatabaseConfig
        if err := m.UnmarshalKey("database", &amp;config); err != nil </span><span class="cov0" title="0">{
                return result.Failure[DatabaseConfig](errors.Wrap(err, "failed to get database config"))
        }</span>
        <span class="cov0" title="0">return result.Success(config)</span>
}

// GetServerConfig retrieves server configuration
func (m *Manager) GetServerConfig() result.Result[ServerConfig] <span class="cov0" title="0">{
        var config ServerConfig
        if err := m.UnmarshalKey("server", &amp;config); err != nil </span><span class="cov0" title="0">{
                return result.Failure[ServerConfig](errors.Wrap(err, "failed to get server config"))
        }</span>
        <span class="cov0" title="0">return result.Success(config)</span>
}

// GetLogConfig retrieves logging configuration
func (m *Manager) GetLogConfig() result.Result[LogConfig] <span class="cov0" title="0">{
        var config LogConfig
        if err := m.UnmarshalKey("logging", &amp;config); err != nil </span><span class="cov0" title="0">{
                return result.Failure[LogConfig](errors.Wrap(err, "failed to get log config"))
        }</span>
        <span class="cov0" title="0">return result.Success(config)</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">// Package di provides advanced dependency injection features
package di

import (
        "context"
        "reflect"
        "sync"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/patterns"
        "github.com/flext/flexcore/shared/result"
)

// AdvancedContainer provides advanced DI features similar to Python's lato and dependency-injector
type AdvancedContainer struct {
        *Container
        providers   map[string]Provider[any]
        decorators  map[string][]Decorator[any]
        interceptors []Interceptor
        scopes      map[string]*Scope
        mu          sync.RWMutex
}

// Provider represents a service provider
type Provider[T any] interface {
        Get(ctx context.Context) result.Result[T]
        GetAsync(ctx context.Context) &lt;-chan result.Result[T]
        Lifecycle() Lifetime
}

// Decorator decorates a service
type Decorator[T any] func(T) T

// Interceptor intercepts service resolution
type Interceptor func(ctx context.Context, serviceName string, next func() result.Result[any]) result.Result[any]

// Scope represents a dependency scope
type Scope struct {
        name      string
        parent    *Scope
        instances map[string]any
        mu        sync.RWMutex
}

// NewAdvancedContainer creates a new advanced DI container
func NewAdvancedContainer() *AdvancedContainer <span class="cov0" title="0">{
        return &amp;AdvancedContainer{
                Container:    NewContainer(),
                providers:    make(map[string]Provider[any]),
                decorators:   make(map[string][]Decorator[any]),
                interceptors: make([]Interceptor, 0),
                scopes:       make(map[string]*Scope),
        }
}</span>

// Provide registers a service using automatic resolution (lato-style)
func (c *AdvancedContainer) Provide(name string, value any) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        provider := NewValueProvider(value)
        c.providers[name] = provider
        return nil
}</span>

// Call executes a function with automatic dependency injection (lato-style)
func (c *AdvancedContainer) Call(ctx context.Context, fn any, args ...any) result.Result[any] <span class="cov0" title="0">{
        fnValue := reflect.ValueOf(fn)
        fnType := fnValue.Type()

        if fnType.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return result.Failure[any](errors.ValidationError("argument must be a function"))
        }</span>

        // Prepare arguments
        <span class="cov0" title="0">callArgs := make([]reflect.Value, fnType.NumIn())
        providedArgIndex := 0

        for i := 0; i &lt; fnType.NumIn(); i++ </span><span class="cov0" title="0">{
                paramType := fnType.In(i)
                paramTypeName := paramType.String()

                // Check if it's context.Context
                if paramType.String() == "context.Context" </span><span class="cov0" title="0">{
                        callArgs[i] = reflect.ValueOf(ctx)
                        continue</span>
                }

                // Try to resolve from container first (except for the last N params where N = len(args))
                <span class="cov0" title="0">argsStartIndex := fnType.NumIn() - len(args)
                if i &gt;= argsStartIndex &amp;&amp; providedArgIndex &lt; len(args) </span><span class="cov0" title="0">{
                        // This parameter should come from explicit args
                        callArgs[i] = reflect.ValueOf(args[providedArgIndex])
                        providedArgIndex++
                        continue</span>
                }

                // Try to resolve from container by type name with interceptors
                <span class="cov0" title="0">if resolved := c.resolveWithInterceptors(ctx, paramTypeName); resolved != nil </span><span class="cov0" title="0">{
                        callArgs[i] = reflect.ValueOf(resolved)
                }</span> else<span class="cov0" title="0"> if resolved := c.resolveByType(ctx, paramType); resolved != nil </span><span class="cov0" title="0">{
                        callArgs[i] = reflect.ValueOf(resolved)
                }</span> else<span class="cov0" title="0"> {
                        // Use zero value
                        callArgs[i] = reflect.Zero(paramType)
                }</span>
        }

        // Call the function
        <span class="cov0" title="0">results := fnValue.Call(callArgs)

        // Handle results
        if len(results) == 0 </span><span class="cov0" title="0">{
                return result.Success[any](nil)
        }</span>

        // Check for error in last result
        <span class="cov0" title="0">if len(results) &gt; 1 </span><span class="cov0" title="0">{
                lastResult := results[len(results)-1]
                if err, ok := lastResult.Interface().(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return result.Failure[any](err)
                }</span>
        }

        <span class="cov0" title="0">return result.Success[any](results[0].Interface())</span>
}

// Execute executes a command/handler with DI (lato-style)
func (c *AdvancedContainer) Execute(ctx context.Context, handler any) result.Result[any] <span class="cov0" title="0">{
        return c.Call(ctx, handler)
}</span>

// Factory creates a factory provider
func Factory[T any](factory func(context.Context) (T, error)) Provider[T] <span class="cov0" title="0">{
        return &amp;FactoryProvider[T]{
                factory:  factory,
                lifetime: Transient,
        }
}</span>

// Singleton creates a singleton provider
func Singleton[T any](factory func(context.Context) (T, error)) Provider[T] <span class="cov0" title="0">{
        return &amp;SingletonProvider[T]{
                FactoryProvider: FactoryProvider[T]{
                        factory:  factory,
                        lifetime: SingletonLifetime,
                },
        }
}</span>

// Value creates a value provider
func Value[T any](value T) Provider[T] <span class="cov0" title="0">{
        return &amp;ValueProvider[T]{
                value:    value,
                lifetime: SingletonLifetime,
        }
}</span>

// Resource creates a resource provider with lifecycle
func Resource[T any](
        factory func(context.Context) (T, error),
        cleanup func(T) error,
) Provider[T] <span class="cov0" title="0">{
        return &amp;ResourceProvider[T]{
                factory:  factory,
                cleanup:  cleanup,
                lifetime: SingletonLifetime,
        }
}</span>

// FactoryProvider provides transient instances
type FactoryProvider[T any] struct {
        factory  func(context.Context) (T, error)
        lifetime Lifetime
}

func (p *FactoryProvider[T]) Get(ctx context.Context) result.Result[T] <span class="cov0" title="0">{
        value, err := p.factory(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[T](err)
        }</span>
        <span class="cov0" title="0">return result.Success(value)</span>
}

func (p *FactoryProvider[T]) GetAsync(ctx context.Context) &lt;-chan result.Result[T] <span class="cov0" title="0">{
        ch := make(chan result.Result[T], 1)
        go func() </span><span class="cov0" title="0">{
                defer close(ch)
                ch &lt;- p.Get(ctx)
        }</span>()
        <span class="cov0" title="0">return ch</span>
}

func (p *FactoryProvider[T]) Lifecycle() Lifetime <span class="cov0" title="0">{
        return p.lifetime
}</span>

// SingletonProvider provides singleton instances
type SingletonProvider[T any] struct {
        FactoryProvider[T]
        instance patterns.Maybe[T]
        once     sync.Once
        mu       sync.RWMutex
}

func (p *SingletonProvider[T]) Get(ctx context.Context) result.Result[T] <span class="cov0" title="0">{
        p.mu.RLock()
        if p.instance.IsPresent() </span><span class="cov0" title="0">{
                p.mu.RUnlock()
                return result.Success(p.instance.OrElse(*new(T)))
        }</span>
        <span class="cov0" title="0">p.mu.RUnlock()

        p.mu.Lock()
        defer p.mu.Unlock()

        // Double-check
        if p.instance.IsPresent() </span><span class="cov0" title="0">{
                return result.Success(p.instance.OrElse(*new(T)))
        }</span>

        <span class="cov0" title="0">value, err := p.factory(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[T](err)
        }</span>

        <span class="cov0" title="0">p.instance = patterns.Some(value)
        return result.Success(value)</span>
}

// ValueProvider provides a constant value
type ValueProvider[T any] struct {
        value    T
        lifetime Lifetime
}

func NewValueProvider[T any](value T) Provider[T] <span class="cov0" title="0">{
        return &amp;ValueProvider[T]{
                value:    value,
                lifetime: SingletonLifetime,
        }
}</span>

func (p *ValueProvider[T]) Get(ctx context.Context) result.Result[T] <span class="cov0" title="0">{
        return result.Success(p.value)
}</span>

func (p *ValueProvider[T]) GetAsync(ctx context.Context) &lt;-chan result.Result[T] <span class="cov0" title="0">{
        ch := make(chan result.Result[T], 1)
        ch &lt;- result.Success(p.value)
        close(ch)
        return ch
}</span>

func (p *ValueProvider[T]) Lifecycle() Lifetime <span class="cov0" title="0">{
        return p.lifetime
}</span>

// ResourceProvider provides resources with lifecycle management
type ResourceProvider[T any] struct {
        factory  func(context.Context) (T, error)
        cleanup  func(T) error
        instance patterns.Maybe[T]
        lifetime Lifetime
        mu       sync.RWMutex
}

func (p *ResourceProvider[T]) Get(ctx context.Context) result.Result[T] <span class="cov0" title="0">{
        p.mu.RLock()
        if p.instance.IsPresent() </span><span class="cov0" title="0">{
                p.mu.RUnlock()
                return result.Success(p.instance.OrElse(*new(T)))
        }</span>
        <span class="cov0" title="0">p.mu.RUnlock()

        p.mu.Lock()
        defer p.mu.Unlock()

        value, err := p.factory(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[T](err)
        }</span>

        <span class="cov0" title="0">p.instance = patterns.Some(value)
        return result.Success(value)</span>
}

func (p *ResourceProvider[T]) GetAsync(ctx context.Context) &lt;-chan result.Result[T] <span class="cov0" title="0">{
        ch := make(chan result.Result[T], 1)
        go func() </span><span class="cov0" title="0">{
                defer close(ch)
                ch &lt;- p.Get(ctx)
        }</span>()
        <span class="cov0" title="0">return ch</span>
}

func (p *ResourceProvider[T]) Lifecycle() Lifetime <span class="cov0" title="0">{
        return SingletonLifetime
}</span>

func (p *ResourceProvider[T]) Cleanup() error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.instance.IsPresent() &amp;&amp; p.cleanup != nil </span><span class="cov0" title="0">{
                value, _ := p.instance.Get()
                if err := p.cleanup(value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">p.instance = patterns.None[T]()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RegisterProvider registers a provider
func (c *AdvancedContainer) RegisterProvider(name string, provider Provider[any]) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.providers[name] = provider
}</span>

// RegisterDecorator registers a decorator for a service
func (c *AdvancedContainer) RegisterDecorator(serviceName string, decorator Decorator[any]) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        
        if _, exists := c.decorators[serviceName]; !exists </span><span class="cov0" title="0">{
                c.decorators[serviceName] = make([]Decorator[any], 0)
        }</span>
        <span class="cov0" title="0">c.decorators[serviceName] = append(c.decorators[serviceName], decorator)</span>
}

// AddInterceptor adds a global interceptor
func (c *AdvancedContainer) AddInterceptor(interceptor Interceptor) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.interceptors = append(c.interceptors, interceptor)
}</span>

// ResolveProvider resolves a service using providers
func ResolveProvider[T any](c *AdvancedContainer, ctx context.Context, name string) result.Result[T] <span class="cov0" title="0">{
        c.mu.RLock()
        provider, exists := c.providers[name]
        c.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return result.Failure[T](errors.NotFoundError("provider " + name))
        }</span>

        // Apply interceptors
        <span class="cov0" title="0">var serviceResult result.Result[any]
        next := func() result.Result[any] </span><span class="cov0" title="0">{
                return provider.Get(ctx)
        }</span>

        // Apply interceptors in reverse order
        <span class="cov0" title="0">for i := len(c.interceptors) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                interceptor := c.interceptors[i]
                currentNext := next
                next = func() result.Result[any] </span><span class="cov0" title="0">{
                        return interceptor(ctx, name, currentNext)
                }</span>
        }

        <span class="cov0" title="0">serviceResult = next()

        if serviceResult.IsFailure() </span><span class="cov0" title="0">{
                return result.Failure[T](serviceResult.Error())
        }</span>

        <span class="cov0" title="0">value := serviceResult.Value()
        
        // Apply decorators
        c.mu.RLock()
        decorators, hasDecorators := c.decorators[name]
        c.mu.RUnlock()

        if hasDecorators </span><span class="cov0" title="0">{
                for _, decorator := range decorators </span><span class="cov0" title="0">{
                        value = decorator(value)
                }</span>
        }

        <span class="cov0" title="0">typed, ok := value.(T)
        if !ok </span><span class="cov0" title="0">{
                return result.Failure[T](errors.ValidationError("type mismatch"))
        }</span>

        <span class="cov0" title="0">return result.Success(typed)</span>
}

// CreateScope creates a new scope
func (c *AdvancedContainer) CreateScope(name string) *Scope <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        scope := &amp;Scope{
                name:      name,
                instances: make(map[string]any),
        }
        c.scopes[name] = scope
        return scope
}</span>

// GetScope retrieves a scope
func (c *AdvancedContainer) GetScope(name string) patterns.Maybe[*Scope] <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if scope, exists := c.scopes[name]; exists </span><span class="cov0" title="0">{
                return patterns.Some(scope)
        }</span>
        <span class="cov0" title="0">return patterns.None[*Scope]()</span>
}

// resolveWithInterceptors resolves a dependency by name with interceptor support
func (c *AdvancedContainer) resolveWithInterceptors(ctx context.Context, name string) any <span class="cov0" title="0">{
        c.mu.RLock()
        interceptors := make([]Interceptor, len(c.interceptors))
        copy(interceptors, c.interceptors)
        c.mu.RUnlock()

        // Get both the resolved value and the actual service name for interceptors
        resolved, serviceName := c.resolveByNameWithServiceName(ctx, name)
        if resolved == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If no interceptors, return the resolved value directly
        <span class="cov0" title="0">if len(interceptors) == 0 </span><span class="cov0" title="0">{
                return resolved
        }</span>

        // Create the next function that returns the already resolved value
        <span class="cov0" title="0">next := func() result.Result[any] </span><span class="cov0" title="0">{
                return result.Success[any](resolved)
        }</span>

        // Apply interceptors in reverse order (like middleware)
        <span class="cov0" title="0">for i := len(interceptors) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                currentNext := next
                interceptor := interceptors[i]
                currentServiceName := serviceName // capture for closure
                next = func() result.Result[any] </span><span class="cov0" title="0">{
                        return interceptor(ctx, currentServiceName, currentNext)
                }</span>
        }

        // Execute the interceptor chain
        <span class="cov0" title="0">result := next()
        if result.IsSuccess() </span><span class="cov0" title="0">{
                return result.Value()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// resolveByType attempts to resolve a dependency by type
func (c *AdvancedContainer) resolveByType(ctx context.Context, paramType reflect.Type) any <span class="cov0" title="0">{
        // This is a simplified version - in production, implement type matching
        return nil
}</span>

// resolveByName attempts to resolve a dependency by name
func (c *AdvancedContainer) resolveByName(ctx context.Context, name string) any <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        
        // First try exact name match
        if provider, exists := c.providers[name]; exists </span><span class="cov0" title="0">{
                result := provider.Get(ctx)
                if result.IsSuccess() </span><span class="cov0" title="0">{
                        return result.Value()
                }</span>
        }

        // Then try to resolve by type name for common types
        <span class="cov0" title="0">switch name </span>{
        case "string":<span class="cov0" title="0">
                // Look for any string provider - include all registered string services
                // Return the first matching string provider we find
                for _, provider := range c.providers </span><span class="cov0" title="0">{
                        if r := provider.Get(ctx); r.IsSuccess() </span><span class="cov0" title="0">{
                                if _, ok := r.Value().(string); ok </span><span class="cov0" title="0">{
                                        return r.Value()
                                }</span>
                        }
                }
        case "int":<span class="cov0" title="0">
                // Look for any int provider
                for _, provider := range c.providers </span><span class="cov0" title="0">{
                        if r := provider.Get(ctx); r.IsSuccess() </span><span class="cov0" title="0">{
                                if _, ok := r.Value().(int); ok </span><span class="cov0" title="0">{
                                        return r.Value()
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// resolveByNameWithServiceName attempts to resolve with proper service name for interceptors
func (c *AdvancedContainer) resolveByNameWithServiceName(ctx context.Context, typeName string) (any, string) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        
        // First try exact name match
        if provider, exists := c.providers[typeName]; exists </span><span class="cov0" title="0">{
                result := provider.Get(ctx)
                if result.IsSuccess() </span><span class="cov0" title="0">{
                        return result.Value(), typeName
                }</span>
        }

        // Then try to resolve by type name and return the actual service name
        <span class="cov0" title="0">switch typeName </span>{
        case "string":<span class="cov0" title="0">
                // Look for any string provider and return both value and service name
                for serviceName, provider := range c.providers </span><span class="cov0" title="0">{
                        if r := provider.Get(ctx); r.IsSuccess() </span><span class="cov0" title="0">{
                                if _, ok := r.Value().(string); ok </span><span class="cov0" title="0">{
                                        return r.Value(), serviceName
                                }</span>
                        }
                }
        case "int":<span class="cov0" title="0">
                // Look for any int provider and return both value and service name
                for serviceName, provider := range c.providers </span><span class="cov0" title="0">{
                        if r := provider.Get(ctx); r.IsSuccess() </span><span class="cov0" title="0">{
                                if _, ok := r.Value().(int); ok </span><span class="cov0" title="0">{
                                        return r.Value(), serviceName
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return nil, ""</span>
}

// Configuration provider
type ConfigurationProvider struct {
        sources map[string]any
        mu      sync.RWMutex
}

func NewConfigurationProvider() *ConfigurationProvider <span class="cov0" title="0">{
        return &amp;ConfigurationProvider{
                sources: make(map[string]any),
        }
}</span>

func (p *ConfigurationProvider) FromEnv(key string) Provider[string] <span class="cov0" title="0">{
        return Factory[string](func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                // In real implementation, read from environment
                return "", nil
        }</span>)
}

func (p *ConfigurationProvider) FromFile(path string) Provider[map[string]any] <span class="cov0" title="0">{
        return Factory[map[string]any](func(ctx context.Context) (map[string]any, error) </span><span class="cov0" title="0">{
                // In real implementation, read from file
                return make(map[string]any), nil
        }</span>)
}

// Builder for fluent container configuration
type ContainerBuilder struct {
        container *AdvancedContainer
}

func NewContainerBuilder() *ContainerBuilder <span class="cov0" title="0">{
        return &amp;ContainerBuilder{
                container: NewAdvancedContainer(),
        }
}</span>

func (b *ContainerBuilder) WithProvider(name string, provider Provider[any]) *ContainerBuilder <span class="cov0" title="0">{
        b.container.RegisterProvider(name, provider)
        return b
}</span>

func (b *ContainerBuilder) WithSingleton(name string, factory func(context.Context) (any, error)) *ContainerBuilder <span class="cov0" title="0">{
        b.container.RegisterProvider(name, Singleton[any](factory))
        return b
}</span>

func (b *ContainerBuilder) WithFactory(name string, factory func(context.Context) (any, error)) *ContainerBuilder <span class="cov0" title="0">{
        b.container.RegisterProvider(name, Factory[any](factory))
        return b
}</span>

func (b *ContainerBuilder) WithValue(name string, value any) *ContainerBuilder <span class="cov0" title="0">{
        b.container.RegisterProvider(name, Value[any](value))
        return b
}</span>

func (b *ContainerBuilder) WithInterceptor(interceptor Interceptor) *ContainerBuilder <span class="cov0" title="0">{
        b.container.AddInterceptor(interceptor)
        return b
}</span>

func (b *ContainerBuilder) Build() *AdvancedContainer <span class="cov0" title="0">{
        return b.container
}</span>

// Common interceptors

// LoggingInterceptor logs service resolution
func LoggingInterceptor(logger interface{ Info(string, ...any) }) Interceptor <span class="cov0" title="0">{
        return func(ctx context.Context, serviceName string, next func() result.Result[any]) result.Result[any] </span><span class="cov0" title="0">{
                logger.Info("Resolving service", "name", serviceName)
                result := next()
                if result.IsSuccess() </span><span class="cov0" title="0">{
                        logger.Info("Service resolved successfully", "name", serviceName)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Service resolution failed", "name", serviceName, "error", result.Error())
                }</span>
                <span class="cov0" title="0">return result</span>
        }
}

// MetricsInterceptor collects metrics
func MetricsInterceptor(collector interface{ RecordServiceResolution(string, bool) }) Interceptor <span class="cov0" title="0">{
        return func(ctx context.Context, serviceName string, next func() result.Result[any]) result.Result[any] </span><span class="cov0" title="0">{
                result := next()
                collector.RecordServiceResolution(serviceName, result.IsSuccess())
                return result
        }</span>
}

// CachingInterceptor caches service instances
func CachingInterceptor(cache map[string]any) Interceptor <span class="cov0" title="0">{
        var mu sync.RWMutex
        return func(ctx context.Context, serviceName string, next func() result.Result[any]) result.Result[any] </span><span class="cov0" title="0">{
                mu.RLock()
                if cached, exists := cache[serviceName]; exists </span><span class="cov0" title="0">{
                        mu.RUnlock()
                        return result.Success[any](cached)
                }</span>
                <span class="cov0" title="0">mu.RUnlock()

                result := next()
                if result.IsSuccess() </span><span class="cov0" title="0">{
                        mu.Lock()
                        cache[serviceName] = result.Value()
                        mu.Unlock()
                }</span>
                <span class="cov0" title="0">return result</span>
        }
}</pre>
		
		<pre class="file" id="file13" style="display: none">// Package di provides dependency injection capabilities for FlexCore
package di

import (
        "fmt"
        "reflect"
        "sync"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Container represents a dependency injection container
type Container struct {
        mu        sync.RWMutex
        services  map[string]*serviceDescriptor
        instances map[string]interface{}
}

// serviceDescriptor describes how to create a service
type serviceDescriptor struct {
        serviceType reflect.Type
        factory     interface{}
        lifetime    Lifetime
        singleton   bool
}

// Lifetime represents the lifetime of a service
type Lifetime int

const (
        // Transient creates a new instance every time
        Transient Lifetime = iota
        // SingletonLifetime creates only one instance
        SingletonLifetime
        // Scoped creates one instance per scope (not implemented yet)
        Scoped
)

// NewContainer creates a new DI container
func NewContainer() *Container <span class="cov0" title="0">{
        return &amp;Container{
                services:  make(map[string]*serviceDescriptor),
                instances: make(map[string]interface{}),
        }
}</span>

// Register registers a service with transient lifetime
func (c *Container) Register(factory interface{}) <span class="cov0" title="0">{
        c.RegisterWithLifetime(factory, Transient)
}</span>

// RegisterSingleton registers a service with singleton lifetime
func (c *Container) RegisterSingleton(factory interface{}) <span class="cov0" title="0">{
        c.RegisterWithLifetime(factory, SingletonLifetime)
}</span>

// RegisterWithLifetime registers a service with the specified lifetime
func (c *Container) RegisterWithLifetime(factory interface{}, lifetime Lifetime) <span class="cov0" title="0">{
        factoryType := reflect.TypeOf(factory)
        if factoryType.Kind() != reflect.Func </span><span class="cov0" title="0">{
                panic("factory must be a function")</span>
        }

        <span class="cov0" title="0">if factoryType.NumOut() == 0 </span><span class="cov0" title="0">{
                panic("factory must return at least one value")</span>
        }

        <span class="cov0" title="0">serviceType := factoryType.Out(0)
        serviceName := getServiceName(serviceType)

        c.mu.Lock()
        defer c.mu.Unlock()

        c.services[serviceName] = &amp;serviceDescriptor{
                serviceType: serviceType,
                factory:     factory,
                lifetime:    lifetime,
                singleton:   lifetime == SingletonLifetime,
        }</span>
}

// RegisterInstance registers a specific instance as a singleton
func (c *Container) RegisterInstance(instance interface{}) <span class="cov0" title="0">{
        instanceType := reflect.TypeOf(instance)
        serviceName := getServiceName(instanceType)

        c.mu.Lock()
        defer c.mu.Unlock()

        c.services[serviceName] = &amp;serviceDescriptor{
                serviceType: instanceType,
                factory:     nil,
                lifetime:    SingletonLifetime,
                singleton:   true,
        }
        c.instances[serviceName] = instance
}</span>

// Resolve resolves a service by type
func Resolve[T any](c *Container) result.Result[T] <span class="cov0" title="0">{
        var zero T
        serviceType := reflect.TypeOf((*T)(nil)).Elem()
        serviceName := getServiceName(serviceType)

        instance, err := c.resolve(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[T](err)
        }</span>

        <span class="cov0" title="0">typedInstance, ok := instance.(T)
        if !ok </span><span class="cov0" title="0">{
                return result.Failure[T](errors.Newf("service %s cannot be cast to type %T", serviceName, zero))
        }</span>

        <span class="cov0" title="0">return result.Success(typedInstance)</span>
}

// ResolveByName resolves a service by name
func (c *Container) ResolveByName(serviceName string) result.Result[interface{}] <span class="cov0" title="0">{
        instance, err := c.resolve(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                return result.Failure[interface{}](err)
        }</span>
        <span class="cov0" title="0">return result.Success(instance)</span>
}

// MustResolve resolves a service and panics if it fails
func MustResolve[T any](c *Container) T <span class="cov0" title="0">{
        return Resolve[T](c).UnwrapOrPanic()
}</span>

// resolve internal resolution logic
func (c *Container) resolve(serviceName string) (interface{}, error) <span class="cov0" title="0">{
        c.mu.RLock()
        descriptor, exists := c.services[serviceName]
        if !exists </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil, errors.NotFoundError(fmt.Sprintf("service %s", serviceName))
        }</span>

        // Check if singleton instance already exists
        <span class="cov0" title="0">if descriptor.singleton </span><span class="cov0" title="0">{
                if instance, exists := c.instances[serviceName]; exists </span><span class="cov0" title="0">{
                        c.mu.RUnlock()
                        return instance, nil
                }</span>
        }
        <span class="cov0" title="0">c.mu.RUnlock()

        // Create new instance
        instance, err := c.createInstance(descriptor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store singleton instance
        <span class="cov0" title="0">if descriptor.singleton </span><span class="cov0" title="0">{
                c.mu.Lock()
                c.instances[serviceName] = instance
                c.mu.Unlock()
        }</span>

        <span class="cov0" title="0">return instance, nil</span>
}

// createInstance creates a new service instance
func (c *Container) createInstance(descriptor *serviceDescriptor) (interface{}, error) <span class="cov0" title="0">{
        if descriptor.factory == nil </span><span class="cov0" title="0">{
                return nil, errors.InternalError("factory is nil")
        }</span>

        <span class="cov0" title="0">factoryValue := reflect.ValueOf(descriptor.factory)
        factoryType := factoryValue.Type()

        // Resolve dependencies
        args := make([]reflect.Value, factoryType.NumIn())
        for i := 0; i &lt; factoryType.NumIn(); i++ </span><span class="cov0" title="0">{
                paramType := factoryType.In(i)
                paramName := getServiceName(paramType)

                dependency, err := c.resolve(paramName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to resolve dependency %s", paramName)
                }</span>

                <span class="cov0" title="0">args[i] = reflect.ValueOf(dependency)</span>
        }

        // Call factory function
        <span class="cov0" title="0">results := factoryValue.Call(args)
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, errors.InternalError("factory returned no values")
        }</span>

        <span class="cov0" title="0">instance := results[0].Interface()

        // Check for error return value
        if len(results) &gt; 1 </span><span class="cov0" title="0">{
                if err, ok := results[1].Interface().(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "factory returned error")
                }</span>
        }

        <span class="cov0" title="0">return instance, nil</span>
}

// getServiceName generates a service name from a type
func getServiceName(serviceType reflect.Type) string <span class="cov0" title="0">{
        if serviceType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                serviceType = serviceType.Elem()
        }</span>

        <span class="cov0" title="0">if serviceType.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                return serviceType.Name()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s.%s", serviceType.PkgPath(), serviceType.Name())</span>
}

// IsRegistered checks if a service is registered
func (c *Container) IsRegistered(serviceName string) bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        _, exists := c.services[serviceName]
        return exists
}</span>

// GetRegisteredServices returns all registered service names
func (c *Container) GetRegisteredServices() []string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        services := make([]string, 0, len(c.services))
        for name := range c.services </span><span class="cov0" title="0">{
                services = append(services, name)
        }</span>
        <span class="cov0" title="0">return services</span>
}

// Clear removes all services and instances
func (c *Container) Clear() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.services = make(map[string]*serviceDescriptor)
        c.instances = make(map[string]interface{})
}</span>

// Scope creates a new scoped container (child container)
func (c *Container) Scope() *Container <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        child := NewContainer()
        
        // Copy service descriptors (but not instances)
        for name, descriptor := range c.services </span><span class="cov0" title="0">{
                child.services[name] = descriptor
        }</span>

        <span class="cov0" title="0">return child</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">// Package handlers provides advanced handler patterns for FlexCore
package handlers

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Handler represents a request handler
type Handler interface {
        Handle(ctx context.Context, req Request) result.Result[Response]
}

// Request represents a generic request
type Request interface {
        Context() context.Context
        ID() string
        Method() string
        Path() string
        Headers() map[string][]string
        Body() interface{}
}

// Response represents a generic response
type Response interface {
        StatusCode() int
        Headers() map[string][]string
        Body() interface{}
}

// Middleware represents a handler middleware
type Middleware func(Handler) Handler

// Chain represents a middleware chain
type Chain struct {
        middlewares []Middleware
}

// NewChain creates a new middleware chain
func NewChain(middlewares ...Middleware) *Chain <span class="cov0" title="0">{
        return &amp;Chain{middlewares: middlewares}
}</span>

// Then chains the middlewares and returns final handler
func (c *Chain) Then(handler Handler) Handler <span class="cov0" title="0">{
        for i := len(c.middlewares) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                handler = c.middlewares[i](handler)
        }</span>
        <span class="cov0" title="0">return handler</span>
}

// Append appends middlewares to the chain
func (c *Chain) Append(middlewares ...Middleware) *Chain <span class="cov0" title="0">{
        newMiddlewares := make([]Middleware, 0, len(c.middlewares)+len(middlewares))
        newMiddlewares = append(newMiddlewares, c.middlewares...)
        newMiddlewares = append(newMiddlewares, middlewares...)
        return &amp;Chain{middlewares: newMiddlewares}
}</span>

// Extend extends the chain with another chain
func (c *Chain) Extend(chain *Chain) *Chain <span class="cov0" title="0">{
        return c.Append(chain.middlewares...)
}</span>

// HandlerFunc is an adapter to allow functions as handlers
type HandlerFunc func(ctx context.Context, req Request) result.Result[Response]

// Handle implements Handler interface
func (f HandlerFunc) Handle(ctx context.Context, req Request) result.Result[Response] <span class="cov0" title="0">{
        return f(ctx, req)
}</span>

// Common Middlewares

// LoggingMiddleware logs requests and responses
func LoggingMiddleware(logger interface{ Info(string, ...interface{}) }) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        start := time.Now()
                        
                        logger.Info("Request started",
                                "id", req.ID(),
                                "method", req.Method(),
                                "path", req.Path(),
                        )
                        
                        result := next.Handle(ctx, req)
                        
                        duration := time.Since(start)
                        
                        if result.IsSuccess() </span><span class="cov0" title="0">{
                                resp := result.Value()
                                logger.Info("Request completed",
                                        "id", req.ID(),
                                        "status", resp.StatusCode(),
                                        "duration", duration,
                                )
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("Request failed",
                                        "id", req.ID(),
                                        "error", result.Error(),
                                        "duration", duration,
                                )
                        }</span>
                        
                        <span class="cov0" title="0">return result</span>
                })
        }
}

// RecoveryMiddleware recovers from panics
func RecoveryMiddleware() Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) (resp result.Result[Response]) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        err := errors.InternalError(fmt.Sprintf("panic recovered: %v", r))
                                        resp = result.Failure[Response](err)
                                }</span>
                        }()
                        
                        <span class="cov0" title="0">return next.Handle(ctx, req)</span>
                })
        }
}

// TimeoutMiddleware adds timeout to requests
func TimeoutMiddleware(timeout time.Duration) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(ctx, timeout)
                        defer cancel()
                        
                        done := make(chan result.Result[Response], 1)
                        
                        go func() </span><span class="cov0" title="0">{
                                done &lt;- next.Handle(ctx, req)
                        }</span>()
                        
                        <span class="cov0" title="0">select </span>{
                        case result := &lt;-done:<span class="cov0" title="0">
                                return result</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return result.Failure[Response](errors.TimeoutError("request timeout"))</span>
                        }
                })
        }
}

// RetryMiddleware adds retry logic
func RetryMiddleware(maxRetries int, backoff time.Duration) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        var lastErr error
                        
                        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                                if attempt &gt; 0 </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-time.After(backoff * time.Duration(attempt)):<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return result.Failure[Response](ctx.Err())</span>
                                        }
                                }
                                
                                <span class="cov0" title="0">result := next.Handle(ctx, req)
                                if result.IsSuccess() </span><span class="cov0" title="0">{
                                        return result
                                }</span>
                                
                                <span class="cov0" title="0">lastErr = result.Error()
                                
                                // Don't retry on client errors
                                if httpErr, ok := lastErr.(*errors.FlexError); ok </span><span class="cov0" title="0">{
                                        if httpErr.Code() == errors.CodeValidation ||
                                           httpErr.Code() == errors.CodeUnauthorized ||
                                           httpErr.Code() == errors.CodeForbidden </span><span class="cov0" title="0">{
                                                return result
                                        }</span>
                                }
                        }
                        
                        <span class="cov0" title="0">return result.Failure[Response](errors.Wrapf(lastErr, "failed after %d retries", maxRetries))</span>
                })
        }
}

// AuthenticationMiddleware adds authentication
func AuthenticationMiddleware(authenticator Authenticator) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        authResult := authenticator.Authenticate(ctx, req)
                        if authResult.IsFailure() </span><span class="cov0" title="0">{
                                return result.Failure[Response](authResult.Error())
                        }</span>
                        
                        // Add authenticated user to context
                        <span class="cov0" title="0">user := authResult.Value()
                        ctx = context.WithValue(ctx, "user", user)
                        
                        return next.Handle(ctx, req)</span>
                })
        }
}

// Authenticator interface
type Authenticator interface {
        Authenticate(ctx context.Context, req Request) result.Result[interface{}]
}

// ValidationMiddleware validates requests
func ValidationMiddleware(validator Validator) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        if err := validator.Validate(req); err != nil </span><span class="cov0" title="0">{
                                return result.Failure[Response](errors.ValidationError(err.Error()))
                        }</span>
                        
                        <span class="cov0" title="0">return next.Handle(ctx, req)</span>
                })
        }
}

// Validator interface
type Validator interface {
        Validate(req Request) error
}

// RateLimitingMiddleware adds rate limiting
func RateLimitingMiddleware(limiter RateLimiter) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        if !limiter.Allow(req.ID()) </span><span class="cov0" title="0">{
                                return result.Failure[Response](errors.ForbiddenError("rate limit exceeded"))
                        }</span>
                        
                        <span class="cov0" title="0">return next.Handle(ctx, req)</span>
                })
        }
}

// RateLimiter interface
type RateLimiter interface {
        Allow(key string) bool
}

// MetricsMiddleware collects metrics
func MetricsMiddleware(collector MetricsCollector) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        start := time.Now()
                        
                        result := next.Handle(ctx, req)
                        
                        duration := time.Since(start)
                        status := 0
                        
                        if result.IsSuccess() </span><span class="cov0" title="0">{
                                status = result.Value().StatusCode()
                        }</span> else<span class="cov0" title="0"> {
                                status = http.StatusInternalServerError
                        }</span>
                        
                        <span class="cov0" title="0">collector.RecordRequest(req.Method(), req.Path(), status, duration)
                        
                        return result</span>
                })
        }
}

// MetricsCollector interface
type MetricsCollector interface {
        RecordRequest(method, path string, status int, duration time.Duration)
}

// TracingMiddleware adds distributed tracing
func TracingMiddleware(tracer Tracer) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        span := tracer.StartSpan(ctx, "handler.request")
                        defer span.End()
                        
                        span.SetAttribute("request.id", req.ID())
                        span.SetAttribute("request.method", req.Method())
                        span.SetAttribute("request.path", req.Path())
                        
                        ctx = span.Context()
                        result := next.Handle(ctx, req)
                        
                        if result.IsSuccess() </span><span class="cov0" title="0">{
                                span.SetAttribute("response.status", result.Value().StatusCode())
                        }</span> else<span class="cov0" title="0"> {
                                span.SetError(result.Error())
                        }</span>
                        
                        <span class="cov0" title="0">return result</span>
                })
        }
}

// Tracer interface for distributed tracing
type Tracer interface {
        StartSpan(ctx context.Context, name string) Span
}

// Span interface for tracing spans
type Span interface {
        Context() context.Context
        SetAttribute(key string, value interface{})
        SetError(err error)
        End()
}

// CORSMiddleware adds CORS headers
func CORSMiddleware(config CORSConfig) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        // Handle preflight
                        if req.Method() == "OPTIONS" </span><span class="cov0" title="0">{
                                return result.Success[Response](&amp;BasicResponse{
                                        status: http.StatusNoContent,
                                        headers: map[string][]string{
                                                "Access-Control-Allow-Origin":  config.AllowedOrigins,
                                                "Access-Control-Allow-Methods": config.AllowedMethods,
                                                "Access-Control-Allow-Headers": config.AllowedHeaders,
                                        },
                                })
                        }</span>
                        
                        <span class="cov0" title="0">result := next.Handle(ctx, req)
                        
                        // Add CORS headers to response
                        if result.IsSuccess() </span><span class="cov0" title="0">{
                                resp := result.Value()
                                headers := resp.Headers()
                                headers["Access-Control-Allow-Origin"] = config.AllowedOrigins
                        }</span>
                        
                        <span class="cov0" title="0">return result</span>
                })
        }
}

// CORSConfig represents CORS configuration
type CORSConfig struct {
        AllowedOrigins []string
        AllowedMethods []string
        AllowedHeaders []string
}

// CompressionMiddleware adds response compression
func CompressionMiddleware() Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        result := next.Handle(ctx, req)
                        
                        if result.IsSuccess() </span>{<span class="cov0" title="0">
                                // In real implementation, compress response body
                                // based on Accept-Encoding header
                        }</span>
                        
                        <span class="cov0" title="0">return result</span>
                })
        }
}

// CacheMiddleware adds caching
func CacheMiddleware(cache Cache) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        // Only cache GET requests
                        if req.Method() != "GET" </span><span class="cov0" title="0">{
                                return next.Handle(ctx, req)
                        }</span>
                        
                        <span class="cov0" title="0">cacheKey := fmt.Sprintf("%s:%s", req.Method(), req.Path())
                        
                        // Check cache
                        if cached := cache.Get(cacheKey); cached != nil </span><span class="cov0" title="0">{
                                if resp, ok := cached.(Response); ok </span><span class="cov0" title="0">{
                                        return result.Success(resp)
                                }</span>
                        }
                        
                        // Execute handler
                        <span class="cov0" title="0">result := next.Handle(ctx, req)
                        
                        // Cache successful responses
                        if result.IsSuccess() </span><span class="cov0" title="0">{
                                cache.Set(cacheKey, result.Value(), time.Minute*5)
                        }</span>
                        
                        <span class="cov0" title="0">return result</span>
                })
        }
}

// Cache interface
type Cache interface {
        Get(key string) interface{}
        Set(key string, value interface{}, ttl time.Duration)
}

// TransformMiddleware transforms requests and responses
func TransformMiddleware(reqTransformer RequestTransformer, respTransformer ResponseTransformer) Middleware <span class="cov0" title="0">{
        return func(next Handler) Handler </span><span class="cov0" title="0">{
                return HandlerFunc(func(ctx context.Context, req Request) result.Result[Response] </span><span class="cov0" title="0">{
                        // Transform request
                        if reqTransformer != nil </span><span class="cov0" title="0">{
                                transformedReq, err := reqTransformer.Transform(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        return result.Failure[Response](err)
                                }</span>
                                <span class="cov0" title="0">req = transformedReq</span>
                        }
                        
                        // Execute handler
                        <span class="cov0" title="0">res := next.Handle(ctx, req)
                        
                        // Transform response
                        if respTransformer != nil &amp;&amp; res.IsSuccess() </span><span class="cov0" title="0">{
                                transformedResp, err := respTransformer.Transform(res.Value())
                                if err != nil </span><span class="cov0" title="0">{
                                        return result.Failure[Response](err)
                                }</span>
                                <span class="cov0" title="0">return result.Success(transformedResp)</span>
                        }
                        
                        <span class="cov0" title="0">return res</span>
                })
        }
}

// RequestTransformer transforms requests
type RequestTransformer interface {
        Transform(req Request) (Request, error)
}

// ResponseTransformer transforms responses
type ResponseTransformer interface {
        Transform(resp Response) (Response, error)
}

// Basic implementations

// BasicRequest is a basic request implementation
type BasicRequest struct {
        ctx     context.Context
        id      string
        method  string
        path    string
        headers map[string][]string
        body    interface{}
}

func (r *BasicRequest) Context() context.Context         <span class="cov0" title="0">{ return r.ctx }</span>
func (r *BasicRequest) ID() string                       <span class="cov0" title="0">{ return r.id }</span>
func (r *BasicRequest) Method() string                   <span class="cov0" title="0">{ return r.method }</span>
func (r *BasicRequest) Path() string                     <span class="cov0" title="0">{ return r.path }</span>
func (r *BasicRequest) Headers() map[string][]string     <span class="cov0" title="0">{ return r.headers }</span>
func (r *BasicRequest) Body() interface{}                <span class="cov0" title="0">{ return r.body }</span>

// BasicResponse is a basic response implementation
type BasicResponse struct {
        status  int
        headers map[string][]string
        body    interface{}
}

func (r *BasicResponse) StatusCode() int              <span class="cov0" title="0">{ return r.status }</span>
func (r *BasicResponse) Headers() map[string][]string  <span class="cov0" title="0">{ return r.headers }</span>
func (r *BasicResponse) Body() interface{}             <span class="cov0" title="0">{ return r.body }</span>

// ChainBuilder provides fluent interface for building chains
type ChainBuilder struct {
        chain *Chain
}

// NewChainBuilder creates a new chain builder
func NewChainBuilder() *ChainBuilder <span class="cov0" title="0">{
        return &amp;ChainBuilder{
                chain: NewChain(),
        }
}</span>

// Use adds middleware to the chain
func (b *ChainBuilder) Use(middleware Middleware) *ChainBuilder <span class="cov0" title="0">{
        b.chain = b.chain.Append(middleware)
        return b
}</span>

// UseLogging adds logging middleware
func (b *ChainBuilder) UseLogging(logger interface{ Info(string, ...interface{}) }) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(LoggingMiddleware(logger))
}</span>

// UseRecovery adds recovery middleware
func (b *ChainBuilder) UseRecovery() *ChainBuilder <span class="cov0" title="0">{
        return b.Use(RecoveryMiddleware())
}</span>

// UseTimeout adds timeout middleware
func (b *ChainBuilder) UseTimeout(timeout time.Duration) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(TimeoutMiddleware(timeout))
}</span>

// UseRetry adds retry middleware
func (b *ChainBuilder) UseRetry(maxRetries int, backoff time.Duration) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(RetryMiddleware(maxRetries, backoff))
}</span>

// UseAuthentication adds authentication middleware
func (b *ChainBuilder) UseAuthentication(auth Authenticator) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(AuthenticationMiddleware(auth))
}</span>

// UseValidation adds validation middleware
func (b *ChainBuilder) UseValidation(validator Validator) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(ValidationMiddleware(validator))
}</span>

// UseRateLimiting adds rate limiting middleware
func (b *ChainBuilder) UseRateLimiting(limiter RateLimiter) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(RateLimitingMiddleware(limiter))
}</span>

// UseMetrics adds metrics middleware
func (b *ChainBuilder) UseMetrics(collector MetricsCollector) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(MetricsMiddleware(collector))
}</span>

// UseTracing adds tracing middleware
func (b *ChainBuilder) UseTracing(tracer Tracer) *ChainBuilder <span class="cov0" title="0">{
        return b.Use(TracingMiddleware(tracer))
}</span>

// Build returns the built chain
func (b *ChainBuilder) Build() *Chain <span class="cov0" title="0">{
        return b.chain
}</pre>
		
		<pre class="file" id="file15" style="display: none">// Package observability provides comprehensive monitoring, metrics, and tracing
package observability

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// MetricsCollector provides real-time metrics collection
type MetricsCollector struct {
        mu      sync.RWMutex
        counters map[string]*Counter
        gauges   map[string]*Gauge
        histograms map[string]*Histogram
        timers   map[string]*Timer
        enabled  bool
}

// Counter represents a monotonically increasing counter
type Counter struct {
        name  string
        value int64
        tags  map[string]string
        mu    sync.RWMutex
}

// Gauge represents a value that can go up and down
type Gauge struct {
        name  string
        value float64
        tags  map[string]string
        mu    sync.RWMutex
}

// Histogram tracks distribution of values
type Histogram struct {
        name    string
        buckets []float64
        counts  []int64
        sum     float64
        count   int64
        tags    map[string]string
        mu      sync.RWMutex
}

// Timer tracks timing information
type Timer struct {
        name      string
        durations []time.Duration
        mu        sync.RWMutex
}

// MetricPoint represents a single metric measurement
type MetricPoint struct {
        Name      string            `json:"name"`
        Type      string            `json:"type"`
        Value     interface{}       `json:"value"`
        Tags      map[string]string `json:"tags"`
        Timestamp time.Time         `json:"timestamp"`
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector() *MetricsCollector <span class="cov0" title="0">{
        return &amp;MetricsCollector{
                counters:   make(map[string]*Counter),
                gauges:     make(map[string]*Gauge),
                histograms: make(map[string]*Histogram),
                timers:     make(map[string]*Timer),
                enabled:    true,
        }
}</span>

// Enable enables metrics collection
func (mc *MetricsCollector) Enable() <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        mc.enabled = true
}</span>

// Disable disables metrics collection
func (mc *MetricsCollector) Disable() <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()
        mc.enabled = false
}</span>

// IsEnabled returns whether metrics collection is enabled
func (mc *MetricsCollector) IsEnabled() bool <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()
        return mc.enabled
}</span>

// Counter operations

// IncrementCounter increments a counter by 1
func (mc *MetricsCollector) IncrementCounter(name string, tags map[string]string) <span class="cov0" title="0">{
        mc.AddToCounter(name, 1, tags)
}</span>

// AddToCounter adds a value to a counter
func (mc *MetricsCollector) AddToCounter(name string, value int64, tags map[string]string) <span class="cov0" title="0">{
        if !mc.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mc.mu.Lock()
        defer mc.mu.Unlock()

        key := mc.getMetricKey(name, tags)
        counter, exists := mc.counters[key]
        if !exists </span><span class="cov0" title="0">{
                counter = &amp;Counter{
                        name: name,
                        tags: tags,
                }
                mc.counters[key] = counter
        }</span>

        <span class="cov0" title="0">counter.mu.Lock()
        counter.value += value
        counter.mu.Unlock()</span>
}

// GetCounter returns the current value of a counter
func (mc *MetricsCollector) GetCounter(name string, tags map[string]string) int64 <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        key := mc.getMetricKey(name, tags)
        if counter, exists := mc.counters[key]; exists </span><span class="cov0" title="0">{
                counter.mu.RLock()
                defer counter.mu.RUnlock()
                return counter.value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Gauge operations

// SetGauge sets a gauge value
func (mc *MetricsCollector) SetGauge(name string, value float64, tags map[string]string) <span class="cov0" title="0">{
        if !mc.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mc.mu.Lock()
        defer mc.mu.Unlock()

        key := mc.getMetricKey(name, tags)
        gauge, exists := mc.gauges[key]
        if !exists </span><span class="cov0" title="0">{
                gauge = &amp;Gauge{
                        name: name,
                        tags: tags,
                }
                mc.gauges[key] = gauge
        }</span>

        <span class="cov0" title="0">gauge.mu.Lock()
        gauge.value = value
        gauge.mu.Unlock()</span>
}

// GetGauge returns the current value of a gauge
func (mc *MetricsCollector) GetGauge(name string, tags map[string]string) float64 <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        key := mc.getMetricKey(name, tags)
        if gauge, exists := mc.gauges[key]; exists </span><span class="cov0" title="0">{
                gauge.mu.RLock()
                defer gauge.mu.RUnlock()
                return gauge.value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Histogram operations

// RecordHistogram records a value in a histogram
func (mc *MetricsCollector) RecordHistogram(name string, value float64, tags map[string]string) <span class="cov0" title="0">{
        if !mc.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mc.mu.Lock()
        defer mc.mu.Unlock()

        key := mc.getMetricKey(name, tags)
        hist, exists := mc.histograms[key]
        if !exists </span><span class="cov0" title="0">{
                // Default buckets: 0.1, 0.5, 1, 2.5, 5, 10, 25, 50, 100
                hist = &amp;Histogram{
                        name:    name,
                        buckets: []float64{0.1, 0.5, 1, 2.5, 5, 10, 25, 50, 100},
                        counts:  make([]int64, 10), // 9 buckets + inf
                        tags:    tags,
                }
                mc.histograms[key] = hist
        }</span>

        <span class="cov0" title="0">hist.mu.Lock()
        defer hist.mu.Unlock()

        hist.sum += value
        hist.count++

        // Find appropriate bucket
        for i, bucket := range hist.buckets </span><span class="cov0" title="0">{
                if value &lt;= bucket </span><span class="cov0" title="0">{
                        hist.counts[i]++
                        break</span>
                }
        }
        // If value is larger than all buckets, increment +Inf bucket
        <span class="cov0" title="0">if value &gt; hist.buckets[len(hist.buckets)-1] </span><span class="cov0" title="0">{
                hist.counts[len(hist.counts)-1]++
        }</span>
}

// Timer operations

// StartTimer starts a new timer
func (mc *MetricsCollector) StartTimer(name string) *TimerContext <span class="cov0" title="0">{
        return &amp;TimerContext{
                collector: mc,
                name:      name,
                startTime: time.Now(),
        }
}</span>

// TimerContext represents an active timer
type TimerContext struct {
        collector *MetricsCollector
        name      string
        startTime time.Time
}

// Stop stops the timer and records the duration
func (tc *TimerContext) Stop() time.Duration <span class="cov0" title="0">{
        duration := time.Since(tc.startTime)
        tc.collector.RecordTimer(tc.name, duration)
        return duration
}</span>

// RecordTimer records a timer duration
func (mc *MetricsCollector) RecordTimer(name string, duration time.Duration) <span class="cov0" title="0">{
        if !mc.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">mc.mu.Lock()
        defer mc.mu.Unlock()

        timer, exists := mc.timers[name]
        if !exists </span><span class="cov0" title="0">{
                timer = &amp;Timer{
                        name: name,
                }
                mc.timers[name] = timer
        }</span>

        <span class="cov0" title="0">timer.mu.Lock()
        timer.durations = append(timer.durations, duration)
        // Keep only last 1000 measurements to prevent memory leak
        if len(timer.durations) &gt; 1000 </span><span class="cov0" title="0">{
                timer.durations = timer.durations[len(timer.durations)-1000:]
        }</span>
        <span class="cov0" title="0">timer.mu.Unlock()

        // Also record as histogram in seconds
        mc.RecordHistogram(name+"_duration_seconds", duration.Seconds(), nil)</span>
}

// GetAllMetrics returns all current metrics
func (mc *MetricsCollector) GetAllMetrics() []MetricPoint <span class="cov0" title="0">{
        mc.mu.RLock()
        defer mc.mu.RUnlock()

        var metrics []MetricPoint
        now := time.Now()

        // Counters
        for _, counter := range mc.counters </span><span class="cov0" title="0">{
                counter.mu.RLock()
                metrics = append(metrics, MetricPoint{
                        Name:      counter.name,
                        Type:      "counter",
                        Value:     counter.value,
                        Tags:      counter.tags,
                        Timestamp: now,
                })
                counter.mu.RUnlock()
        }</span>

        // Gauges
        <span class="cov0" title="0">for _, gauge := range mc.gauges </span><span class="cov0" title="0">{
                gauge.mu.RLock()
                metrics = append(metrics, MetricPoint{
                        Name:      gauge.name,
                        Type:      "gauge",
                        Value:     gauge.value,
                        Tags:      gauge.tags,
                        Timestamp: now,
                })
                gauge.mu.RUnlock()
        }</span>

        // Histograms
        <span class="cov0" title="0">for _, hist := range mc.histograms </span><span class="cov0" title="0">{
                hist.mu.RLock()
                metrics = append(metrics, MetricPoint{
                        Name:      hist.name + "_sum",
                        Type:      "histogram_sum",
                        Value:     hist.sum,
                        Tags:      hist.tags,
                        Timestamp: now,
                })
                metrics = append(metrics, MetricPoint{
                        Name:      hist.name + "_count",
                        Type:      "histogram_count",
                        Value:     hist.count,
                        Tags:      hist.tags,
                        Timestamp: now,
                })
                hist.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// Reset clears all metrics
func (mc *MetricsCollector) Reset() <span class="cov0" title="0">{
        mc.mu.Lock()
        defer mc.mu.Unlock()

        mc.counters = make(map[string]*Counter)
        mc.gauges = make(map[string]*Gauge)
        mc.histograms = make(map[string]*Histogram)
        mc.timers = make(map[string]*Timer)
}</span>

// getMetricKey generates a unique key for a metric with tags
func (mc *MetricsCollector) getMetricKey(name string, tags map[string]string) string <span class="cov0" title="0">{
        key := name
        if tags != nil </span><span class="cov0" title="0">{
                for k, v := range tags </span><span class="cov0" title="0">{
                        key += fmt.Sprintf("_%s_%s", k, v)
                }</span>
        }
        <span class="cov0" title="0">return key</span>
}

// Name returns the name of the metrics collector for health checking
func (mc *MetricsCollector) Name() string <span class="cov0" title="0">{
        return "metrics-collector"
}</span>

// Health check for metrics collector
func (mc *MetricsCollector) HealthCheck(ctx context.Context) result.Result[bool] <span class="cov0" title="0">{
        if !mc.IsEnabled() </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("metrics collector is disabled"))
        }</span>

        <span class="cov0" title="0">mc.mu.RLock()
        defer mc.mu.RUnlock()

        // Check if we have any metrics (indicates system is working)
        totalMetrics := len(mc.counters) + len(mc.gauges) + len(mc.histograms) + len(mc.timers)
        
        return result.Success(totalMetrics &gt;= 0)</span> // Always healthy if enabled
}</pre>
		
		<pre class="file" id="file16" style="display: none">// Package observability provides real-time monitoring capabilities
package observability

import (
        "context"
        "fmt"
        "runtime"
        "sync"
        "time"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Monitor provides real-time system monitoring
type Monitor struct {
        mu              sync.RWMutex
        metrics         *MetricsCollector
        tracer          *Tracer
        healthCheckers  map[string]HealthChecker
        alerts          []Alert
        config          MonitorConfig
        running         bool
        stopCh          chan struct{}
        alertCh         chan Alert
        subscribers     []MonitorSubscriber
}

// MonitorConfig configures the monitor
type MonitorConfig struct {
        MetricsInterval   time.Duration
        HealthInterval    time.Duration
        ResourceInterval  time.Duration
        MaxAlerts         int
        AlertThresholds   AlertThresholds
}

// AlertThresholds defines alert thresholds
type AlertThresholds struct {
        CPUPercent     float64
        MemoryMB       float64
        GoroutinesMax  int
        LatencyMS      float64
        ErrorRatePercent float64
}

// HealthChecker interface for health checks
type HealthChecker interface {
        HealthCheck(ctx context.Context) result.Result[bool]
        Name() string
}

// Alert represents a monitoring alert
type Alert struct {
        ID          string                 `json:"id"`
        Type        AlertType              `json:"type"`
        Severity    AlertSeverity          `json:"severity"`
        Title       string                 `json:"title"`
        Message     string                 `json:"message"`
        Timestamp   time.Time              `json:"timestamp"`
        Metadata    map[string]interface{} `json:"metadata"`
        Resolved    bool                   `json:"resolved"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty"`
}

// AlertType represents the type of alert
type AlertType string

const (
        AlertTypeSystem    AlertType = "system"
        AlertTypeHealth    AlertType = "health"
        AlertTypeLatency   AlertType = "latency"
        AlertTypeErrorRate AlertType = "error_rate"
        AlertTypeCustom    AlertType = "custom"
)

// AlertSeverity represents alert severity
type AlertSeverity string

const (
        AlertSeverityInfo     AlertSeverity = "info"
        AlertSeverityWarning  AlertSeverity = "warning"
        AlertSeverityError    AlertSeverity = "error"
        AlertSeverityCritical AlertSeverity = "critical"
)

// MonitorSubscriber receives monitoring events
type MonitorSubscriber interface {
        OnAlert(alert Alert)
        OnMetricsUpdate(metrics []MetricPoint)
        OnHealthUpdate(status HealthStatus)
}

// HealthStatus represents overall system health
type HealthStatus struct {
        Overall   HealthState            `json:"overall"`
        Services  map[string]HealthState `json:"services"`
        Timestamp time.Time              `json:"timestamp"`
        Details   map[string]interface{} `json:"details"`
}

// HealthState represents health state
type HealthState string

const (
        HealthStateHealthy   HealthState = "healthy"
        HealthStateWarning   HealthState = "warning"
        HealthStateUnhealthy HealthState = "unhealthy"
        HealthStateUnknown   HealthState = "unknown"
)

// SystemMetrics represents system resource metrics
type SystemMetrics struct {
        CPUPercent    float64 `json:"cpu_percent"`
        MemoryMB      float64 `json:"memory_mb"`
        Goroutines    int     `json:"goroutines"`
        HeapMB        float64 `json:"heap_mb"`
        GCPauseMS     float64 `json:"gc_pause_ms"`
        Uptime        time.Duration `json:"uptime"`
}

// NewMonitor creates a new monitor
func NewMonitor(metrics *MetricsCollector, tracer *Tracer, config MonitorConfig) *Monitor <span class="cov0" title="0">{
        if config.MetricsInterval == 0 </span><span class="cov0" title="0">{
                config.MetricsInterval = 10 * time.Second
        }</span>
        <span class="cov0" title="0">if config.HealthInterval == 0 </span><span class="cov0" title="0">{
                config.HealthInterval = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.ResourceInterval == 0 </span><span class="cov0" title="0">{
                config.ResourceInterval = 5 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxAlerts == 0 </span><span class="cov0" title="0">{
                config.MaxAlerts = 1000
        }</span>

        // Set default thresholds
        <span class="cov0" title="0">if config.AlertThresholds.CPUPercent == 0 </span><span class="cov0" title="0">{
                config.AlertThresholds.CPUPercent = 80.0
        }</span>
        <span class="cov0" title="0">if config.AlertThresholds.MemoryMB == 0 </span><span class="cov0" title="0">{
                config.AlertThresholds.MemoryMB = 1024.0
        }</span>
        <span class="cov0" title="0">if config.AlertThresholds.GoroutinesMax == 0 </span><span class="cov0" title="0">{
                config.AlertThresholds.GoroutinesMax = 10000
        }</span>
        <span class="cov0" title="0">if config.AlertThresholds.LatencyMS == 0 </span><span class="cov0" title="0">{
                config.AlertThresholds.LatencyMS = 1000.0
        }</span>
        <span class="cov0" title="0">if config.AlertThresholds.ErrorRatePercent == 0 </span><span class="cov0" title="0">{
                config.AlertThresholds.ErrorRatePercent = 5.0
        }</span>

        <span class="cov0" title="0">return &amp;Monitor{
                metrics:        metrics,
                tracer:         tracer,
                healthCheckers: make(map[string]HealthChecker),
                alerts:         make([]Alert, 0),
                config:         config,
                stopCh:         make(chan struct{}),
                alertCh:        make(chan Alert, 100),
                subscribers:    make([]MonitorSubscriber, 0),
        }</span>
}

// Start starts the monitor
func (m *Monitor) Start(ctx context.Context) error <span class="cov0" title="0">{
        m.mu.Lock()
        if m.running </span><span class="cov0" title="0">{
                m.mu.Unlock()
                return errors.ValidationError("monitor is already running")
        }</span>
        <span class="cov0" title="0">m.running = true
        m.mu.Unlock()

        // Start monitoring goroutines
        go m.metricsLoop(ctx)
        go m.healthLoop(ctx)
        go m.resourceLoop(ctx)
        go m.alertLoop(ctx)

        return nil</span>
}

// Stop stops the monitor
func (m *Monitor) Stop() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if !m.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.running = false
        close(m.stopCh)</span>
}

// AddHealthChecker adds a health checker
func (m *Monitor) AddHealthChecker(checker HealthChecker) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.healthCheckers[checker.Name()] = checker
}</span>

// RemoveHealthChecker removes a health checker
func (m *Monitor) RemoveHealthChecker(name string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.healthCheckers, name)
}</span>

// Subscribe adds a monitor subscriber
func (m *Monitor) Subscribe(subscriber MonitorSubscriber) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.subscribers = append(m.subscribers, subscriber)
}</span>

// CreateAlert creates a new alert
func (m *Monitor) CreateAlert(alertType AlertType, severity AlertSeverity, title, message string, metadata map[string]interface{}) <span class="cov0" title="0">{
        alert := Alert{
                ID:        m.generateAlertID(),
                Type:      alertType,
                Severity:  severity,
                Title:     title,
                Message:   message,
                Timestamp: time.Now(),
                Metadata:  metadata,
                Resolved:  false,
        }

        select </span>{
        case m.alertCh &lt;- alert:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Alert channel is full, drop the alert
        }
}

// GetAlerts returns current alerts
func (m *Monitor) GetAlerts() []Alert <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        alerts := make([]Alert, len(m.alerts))
        copy(alerts, m.alerts)
        return alerts
}</span>

// GetHealthStatus returns current health status
func (m *Monitor) GetHealthStatus(ctx context.Context) HealthStatus <span class="cov0" title="0">{
        m.mu.RLock()
        checkers := make(map[string]HealthChecker)
        for name, checker := range m.healthCheckers </span><span class="cov0" title="0">{
                checkers[name] = checker
        }</span>
        <span class="cov0" title="0">m.mu.RUnlock()

        status := HealthStatus{
                Services:  make(map[string]HealthState),
                Timestamp: time.Now(),
                Details:   make(map[string]interface{}),
        }

        overall := HealthStateHealthy
        healthyCount := 0
        totalCount := len(checkers)

        for name, checker := range checkers </span><span class="cov0" title="0">{
                result := checker.HealthCheck(ctx)
                if result.IsSuccess() &amp;&amp; result.Value() </span><span class="cov0" title="0">{
                        status.Services[name] = HealthStateHealthy
                        healthyCount++
                }</span> else<span class="cov0" title="0"> {
                        status.Services[name] = HealthStateUnhealthy
                        if overall == HealthStateHealthy </span><span class="cov0" title="0">{
                                overall = HealthStateWarning
                        }</span>
                        <span class="cov0" title="0">if result.IsFailure() </span><span class="cov0" title="0">{
                                status.Details[name+"_error"] = result.Error().Error()
                        }</span>
                }
        }

        // Determine overall health
        <span class="cov0" title="0">if totalCount == 0 </span><span class="cov0" title="0">{
                overall = HealthStateUnknown
        }</span> else<span class="cov0" title="0"> if healthyCount == 0 </span><span class="cov0" title="0">{
                overall = HealthStateUnhealthy
        }</span> else<span class="cov0" title="0"> if healthyCount &lt; totalCount </span><span class="cov0" title="0">{
                overall = HealthStateWarning
        }</span>

        <span class="cov0" title="0">status.Overall = overall
        return status</span>
}

// GetSystemMetrics returns current system metrics
func (m *Monitor) GetSystemMetrics() SystemMetrics <span class="cov0" title="0">{
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        return SystemMetrics{
                CPUPercent: 0.0, // Would need additional CPU monitoring
                MemoryMB:   float64(memStats.Alloc) / 1024 / 1024,
                Goroutines: runtime.NumGoroutine(),
                HeapMB:     float64(memStats.HeapAlloc) / 1024 / 1024,
                GCPauseMS:  float64(memStats.PauseNs[(memStats.NumGC+255)%256]) / 1000000,
                Uptime:     time.Since(time.Now()), // Would track actual uptime
        }
}</span>

// Monitor loops

func (m *Monitor) metricsLoop(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(m.config.MetricsInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-m.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.collectMetrics()</span>
                }
        }
}

func (m *Monitor) healthLoop(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(m.config.HealthInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-m.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.checkHealth(ctx)</span>
                }
        }
}

func (m *Monitor) resourceLoop(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(m.config.ResourceInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-m.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.monitorResources()</span>
                }
        }
}

func (m *Monitor) alertLoop(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-m.stopCh:<span class="cov0" title="0">
                        return</span>
                case alert := &lt;-m.alertCh:<span class="cov0" title="0">
                        m.processAlert(alert)</span>
                }
        }
}

func (m *Monitor) collectMetrics() <span class="cov0" title="0">{
        if m.metrics == nil || !m.metrics.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        // Collect system metrics
        <span class="cov0" title="0">sysMetrics := m.GetSystemMetrics()
        
        m.metrics.SetGauge("system_memory_mb", sysMetrics.MemoryMB, nil)
        m.metrics.SetGauge("system_goroutines", float64(sysMetrics.Goroutines), nil)
        m.metrics.SetGauge("system_heap_mb", sysMetrics.HeapMB, nil)
        m.metrics.SetGauge("system_gc_pause_ms", sysMetrics.GCPauseMS, nil)

        // Check thresholds
        if sysMetrics.MemoryMB &gt; m.config.AlertThresholds.MemoryMB </span><span class="cov0" title="0">{
                m.CreateAlert(AlertTypeSystem, AlertSeverityWarning, 
                        "High Memory Usage", 
                        fmt.Sprintf("Memory usage: %.2f MB", sysMetrics.MemoryMB), 
                        map[string]interface{}{"memory_mb": sysMetrics.MemoryMB})
        }</span>

        <span class="cov0" title="0">if sysMetrics.Goroutines &gt; m.config.AlertThresholds.GoroutinesMax </span><span class="cov0" title="0">{
                m.CreateAlert(AlertTypeSystem, AlertSeverityWarning, 
                        "High Goroutine Count", 
                        fmt.Sprintf("Goroutines: %d", sysMetrics.Goroutines), 
                        map[string]interface{}{"goroutines": sysMetrics.Goroutines})
        }</span>

        // Notify subscribers
        <span class="cov0" title="0">m.notifyMetricsUpdate()</span>
}

func (m *Monitor) checkHealth(ctx context.Context) <span class="cov0" title="0">{
        status := m.GetHealthStatus(ctx)
        
        // Create alerts for unhealthy services
        for service, state := range status.Services </span><span class="cov0" title="0">{
                if state == HealthStateUnhealthy </span><span class="cov0" title="0">{
                        m.CreateAlert(AlertTypeHealth, AlertSeverityError, 
                                "Service Unhealthy", 
                                fmt.Sprintf("Service %s is unhealthy", service), 
                                map[string]interface{}{"service": service})
                }</span>
        }

        // Notify subscribers
        <span class="cov0" title="0">m.notifyHealthUpdate(status)</span>
}

func (m *Monitor) monitorResources() {<span class="cov0" title="0">
        // Additional resource monitoring would go here
        // For now, this is handled in collectMetrics
}</span>

func (m *Monitor) processAlert(alert Alert) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Add to alerts list
        m.alerts = append(m.alerts, alert)

        // Limit alerts to prevent memory leak
        if len(m.alerts) &gt; m.config.MaxAlerts </span><span class="cov0" title="0">{
                m.alerts = m.alerts[len(m.alerts)-m.config.MaxAlerts:]
        }</span>

        // Notify subscribers
        <span class="cov0" title="0">for _, subscriber := range m.subscribers </span><span class="cov0" title="0">{
                go subscriber.OnAlert(alert)
        }</span>
}

func (m *Monitor) notifyMetricsUpdate() <span class="cov0" title="0">{
        if m.metrics == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">metrics := m.metrics.GetAllMetrics()
        
        m.mu.RLock()
        subscribers := make([]MonitorSubscriber, len(m.subscribers))
        copy(subscribers, m.subscribers)
        m.mu.RUnlock()

        for _, subscriber := range subscribers </span><span class="cov0" title="0">{
                go subscriber.OnMetricsUpdate(metrics)
        }</span>
}

func (m *Monitor) notifyHealthUpdate(status HealthStatus) <span class="cov0" title="0">{
        m.mu.RLock()
        subscribers := make([]MonitorSubscriber, len(m.subscribers))
        copy(subscribers, m.subscribers)
        m.mu.RUnlock()

        for _, subscriber := range subscribers </span><span class="cov0" title="0">{
                go subscriber.OnHealthUpdate(status)
        }</span>
}

func (m *Monitor) generateAlertID() string <span class="cov0" title="0">{
        return fmt.Sprintf("alert_%d", time.Now().UnixNano())
}</span>

// IsRunning returns whether the monitor is running
func (m *Monitor) IsRunning() bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.running
}</pre>
		
		<pre class="file" id="file17" style="display: none">// Package observability provides distributed tracing capabilities
package observability

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Tracer provides distributed tracing functionality
type Tracer struct {
        mu            sync.RWMutex
        serviceName   string
        spans         map[string]*Span
        activeSpans   map[string]*Span
        maxSpans      int
        enabled       bool
        exporters     []TraceExporter
}

// Span represents a single trace span
type Span struct {
        TraceID       string                 `json:"trace_id"`
        SpanID        string                 `json:"span_id"`
        ParentSpanID  string                 `json:"parent_span_id,omitempty"`
        OperationName string                 `json:"operation_name"`
        StartTime     time.Time              `json:"start_time"`
        EndTime       *time.Time             `json:"end_time,omitempty"`
        Duration      *time.Duration         `json:"duration,omitempty"`
        Tags          map[string]interface{} `json:"tags"`
        Status        SpanStatus             `json:"status"`
        Events        []SpanEvent            `json:"events"`
        ServiceName   string                 `json:"service_name"`
        mu            sync.RWMutex
}

// SpanStatus represents the status of a span
type SpanStatus struct {
        Code    SpanStatusCode `json:"code"`
        Message string         `json:"message"`
}

// SpanStatusCode represents status codes
type SpanStatusCode int

const (
        SpanStatusOK SpanStatusCode = iota
        SpanStatusError
        SpanStatusTimeout
        SpanStatusCanceled
)

// SpanEvent represents an event within a span
type SpanEvent struct {
        Name       string                 `json:"name"`
        Timestamp  time.Time              `json:"timestamp"`
        Attributes map[string]interface{} `json:"attributes"`
}

// TraceExporter exports traces to external systems
type TraceExporter interface {
        Export(ctx context.Context, spans []*Span) error
        Name() string
}

// SpanContext represents the context for a span
type SpanContext struct {
        TraceID  string
        SpanID   string
        Sampled  bool
        TraceState map[string]string
}

// NewTracer creates a new tracer
func NewTracer(serviceName string, maxSpans int) *Tracer <span class="cov0" title="0">{
        if maxSpans &lt;= 0 </span><span class="cov0" title="0">{
                maxSpans = 10000 // Default max spans
        }</span>

        <span class="cov0" title="0">return &amp;Tracer{
                serviceName: serviceName,
                spans:       make(map[string]*Span),
                activeSpans: make(map[string]*Span),
                maxSpans:    maxSpans,
                enabled:     true,
                exporters:   make([]TraceExporter, 0),
        }</span>
}

// Enable enables tracing
func (t *Tracer) Enable() <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.enabled = true
}</span>

// Disable disables tracing
func (t *Tracer) Disable() <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.enabled = false
}</span>

// IsEnabled returns whether tracing is enabled
func (t *Tracer) IsEnabled() bool <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.enabled
}</span>

// AddExporter adds a trace exporter
func (t *Tracer) AddExporter(exporter TraceExporter) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.exporters = append(t.exporters, exporter)
}</span>

// StartSpan starts a new span
func (t *Tracer) StartSpan(ctx context.Context, operationName string) (*Span, context.Context) <span class="cov0" title="0">{
        if !t.IsEnabled() </span><span class="cov0" title="0">{
                return nil, ctx
        }</span>

        // Extract parent span from context if exists
        <span class="cov0" title="0">var parentSpanID string
        var traceID string

        if parentSpan := SpanFromContext(ctx); parentSpan != nil </span><span class="cov0" title="0">{
                parentSpanID = parentSpan.SpanID
                traceID = parentSpan.TraceID
        }</span> else<span class="cov0" title="0"> {
                traceID = t.generateTraceID()
        }</span>

        <span class="cov0" title="0">spanID := t.generateSpanID()
        
        span := &amp;Span{
                TraceID:       traceID,
                SpanID:        spanID,
                ParentSpanID:  parentSpanID,
                OperationName: operationName,
                StartTime:     time.Now(),
                Tags:          make(map[string]interface{}),
                Status:        SpanStatus{Code: SpanStatusOK},
                Events:        make([]SpanEvent, 0),
                ServiceName:   t.serviceName,
        }

        t.mu.Lock()
        // Prevent memory leak by limiting spans
        if len(t.spans) &gt;= t.maxSpans </span><span class="cov0" title="0">{
                // Remove oldest spans (simple cleanup)
                for id := range t.spans </span><span class="cov0" title="0">{
                        delete(t.spans, id)
                        if len(t.spans) &lt; t.maxSpans/2 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">t.spans[spanID] = span
        t.activeSpans[spanID] = span
        t.mu.Unlock()

        // Add span to context
        newCtx := ContextWithSpan(ctx, span)
        
        return span, newCtx</span>
}

// FinishSpan finishes a span
func (t *Tracer) FinishSpan(span *Span) <span class="cov0" title="0">{
        if span == nil || !t.IsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">span.mu.Lock()
        endTime := time.Now()
        span.EndTime = &amp;endTime
        duration := endTime.Sub(span.StartTime)
        span.Duration = &amp;duration
        span.mu.Unlock()

        t.mu.Lock()
        delete(t.activeSpans, span.SpanID)
        t.mu.Unlock()

        // Export to all exporters
        go t.exportSpan(span)</span>
}

// SetSpanTag sets a tag on a span
func (t *Tracer) SetSpanTag(span *Span, key string, value interface{}) <span class="cov0" title="0">{
        if span == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">span.mu.Lock()
        defer span.mu.Unlock()
        span.Tags[key] = value</span>
}

// SetSpanStatus sets the status of a span
func (t *Tracer) SetSpanStatus(span *Span, code SpanStatusCode, message string) <span class="cov0" title="0">{
        if span == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">span.mu.Lock()
        defer span.mu.Unlock()
        span.Status = SpanStatus{
                Code:    code,
                Message: message,
        }</span>
}

// AddSpanEvent adds an event to a span
func (t *Tracer) AddSpanEvent(span *Span, name string, attributes map[string]interface{}) <span class="cov0" title="0">{
        if span == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">event := SpanEvent{
                Name:       name,
                Timestamp:  time.Now(),
                Attributes: attributes,
        }

        span.mu.Lock()
        defer span.mu.Unlock()
        span.Events = append(span.Events, event)</span>
}

// GetSpan retrieves a span by ID
func (t *Tracer) GetSpan(spanID string) *Span <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.spans[spanID]
}</span>

// GetActiveSpans returns all active spans
func (t *Tracer) GetActiveSpans() []*Span <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        spans := make([]*Span, 0, len(t.activeSpans))
        for _, span := range t.activeSpans </span><span class="cov0" title="0">{
                spans = append(spans, span)
        }</span>
        <span class="cov0" title="0">return spans</span>
}

// GetAllSpans returns all spans
func (t *Tracer) GetAllSpans() []*Span <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        spans := make([]*Span, 0, len(t.spans))
        for _, span := range t.spans </span><span class="cov0" title="0">{
                spans = append(spans, span)
        }</span>
        <span class="cov0" title="0">return spans</span>
}

// exportSpan exports a span to all configured exporters
func (t *Tracer) exportSpan(span *Span) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        t.mu.RLock()
        exporters := make([]TraceExporter, len(t.exporters))
        copy(exporters, t.exporters)
        t.mu.RUnlock()

        for _, exporter := range exporters </span><span class="cov0" title="0">{
                if err := exporter.Export(ctx, []*Span{span}); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the operation
                        fmt.Printf("Failed to export span to %s: %v\n", exporter.Name(), err)
                }</span>
        }
}

// generateTraceID generates a new trace ID
func (t *Tracer) generateTraceID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// generateSpanID generates a new span ID
func (t *Tracer) generateSpanID() string <span class="cov0" title="0">{
        bytes := make([]byte, 8)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// Context utilities for span propagation

type spanContextKey struct{}

// ContextWithSpan returns a new context with the span attached
func ContextWithSpan(ctx context.Context, span *Span) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, spanContextKey{}, span)
}</span>

// SpanFromContext extracts a span from the context
func SpanFromContext(ctx context.Context) *Span <span class="cov0" title="0">{
        if span, ok := ctx.Value(spanContextKey{}).(*Span); ok </span><span class="cov0" title="0">{
                return span
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TraceFromContext extracts the trace ID from the context
func TraceFromContext(ctx context.Context) string <span class="cov0" title="0">{
        if span := SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                return span.TraceID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// InMemoryExporter exports traces to memory (for testing/debugging)
type InMemoryExporter struct {
        mu    sync.RWMutex
        spans []*Span
}

// NewInMemoryExporter creates a new in-memory exporter
func NewInMemoryExporter() *InMemoryExporter <span class="cov0" title="0">{
        return &amp;InMemoryExporter{
                spans: make([]*Span, 0),
        }
}</span>

// Export exports spans to memory
func (e *InMemoryExporter) Export(ctx context.Context, spans []*Span) error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.spans = append(e.spans, spans...)
        return nil
}</span>

// Name returns the exporter name
func (e *InMemoryExporter) Name() string <span class="cov0" title="0">{
        return "in-memory"
}</span>

// GetSpans returns all exported spans
func (e *InMemoryExporter) GetSpans() []*Span <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        
        result := make([]*Span, len(e.spans))
        copy(result, e.spans)
        return result
}</span>

// Clear clears all stored spans
func (e *InMemoryExporter) Clear() <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()
        e.spans = e.spans[:0]
}</span>

// Name returns the name of the tracer for health checking
func (t *Tracer) Name() string <span class="cov0" title="0">{
        return "distributed-tracer"
}</span>

// Health check for tracer
func (t *Tracer) HealthCheck(ctx context.Context) result.Result[bool] <span class="cov0" title="0">{
        if !t.IsEnabled() </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.ValidationError("tracer is disabled"))
        }</span>

        <span class="cov0" title="0">t.mu.RLock()
        defer t.mu.RUnlock()

        // Check if tracer is functional
        activeCount := len(t.activeSpans)
        totalCount := len(t.spans)
        
        // Tracer is healthy if it's enabled and not overloaded
        healthy := totalCount &lt; t.maxSpans &amp;&amp; activeCount &lt; t.maxSpans/2
        
        if !healthy </span><span class="cov0" title="0">{
                return result.Failure[bool](errors.InternalError(
                        fmt.Sprintf("tracer overloaded: %d/%d spans, %d active", 
                                totalCount, t.maxSpans, activeCount)))
        }</span>
        
        <span class="cov0" title="0">return result.Success(true)</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">// Package persistence provides repository implementations
package persistence

import (
        "context"
        "database/sql"
        "encoding/json"
        "sync"

        "github.com/flext/flexcore/domain/entities"
        "github.com/flext/flexcore/shared/errors"
        "github.com/lib/pq"
)

// InMemoryPipelineRepository provides an in-memory implementation of pipeline repository
type InMemoryPipelineRepository struct {
        mu        sync.RWMutex
        pipelines map[entities.PipelineID]*entities.Pipeline
        nameIndex map[string]entities.PipelineID
}

// NewInMemoryPipelineRepository creates a new in-memory pipeline repository
func NewInMemoryPipelineRepository() *InMemoryPipelineRepository <span class="cov0" title="0">{
        return &amp;InMemoryPipelineRepository{
                pipelines: make(map[entities.PipelineID]*entities.Pipeline),
                nameIndex: make(map[string]entities.PipelineID),
        }
}</span>

// Save saves a pipeline
func (r *InMemoryPipelineRepository) Save(ctx context.Context, pipeline *entities.Pipeline) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Update name index
        r.nameIndex[pipeline.Name] = pipeline.ID

        // Deep copy to avoid mutations
        r.pipelines[pipeline.ID] = pipeline
        return nil
}</span>

// FindByID finds a pipeline by ID
func (r *InMemoryPipelineRepository) FindByID(ctx context.Context, id entities.PipelineID) (*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        pipeline, exists := r.pipelines[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return pipeline, nil</span>
}

// FindByName finds a pipeline by name
func (r *InMemoryPipelineRepository) FindByName(ctx context.Context, name string) (*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        id, exists := r.nameIndex[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return r.pipelines[id], nil</span>
}

// Delete deletes a pipeline
func (r *InMemoryPipelineRepository) Delete(ctx context.Context, id entities.PipelineID) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        pipeline, exists := r.pipelines[id]
        if !exists </span><span class="cov0" title="0">{
                return errors.NotFoundError("pipeline")
        }</span>

        <span class="cov0" title="0">delete(r.nameIndex, pipeline.Name)
        delete(r.pipelines, id)
        return nil</span>
}

// List lists pipelines with pagination
func (r *InMemoryPipelineRepository) List(ctx context.Context, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Convert map to slice
        all := make([]*entities.Pipeline, 0, len(r.pipelines))
        for _, p := range r.pipelines </span><span class="cov0" title="0">{
                all = append(all, p)
        }</span>

        // Apply pagination
        <span class="cov0" title="0">start := offset
        if start &gt; len(all) </span><span class="cov0" title="0">{
                return []*entities.Pipeline{}, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(all) </span><span class="cov0" title="0">{
                end = len(all)
        }</span>

        <span class="cov0" title="0">return all[start:end], nil</span>
}

// Count counts total pipelines
func (r *InMemoryPipelineRepository) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return len(r.pipelines), nil
}</span>

// FindByOwner finds pipelines by owner
func (r *InMemoryPipelineRepository) FindByOwner(ctx context.Context, owner string, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        filtered := make([]*entities.Pipeline, 0)
        for _, p := range r.pipelines </span><span class="cov0" title="0">{
                if p.Owner == owner </span><span class="cov0" title="0">{
                        filtered = append(filtered, p)
                }</span>
        }

        // Apply pagination
        <span class="cov0" title="0">start := offset
        if start &gt; len(filtered) </span><span class="cov0" title="0">{
                return []*entities.Pipeline{}, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(filtered) </span><span class="cov0" title="0">{
                end = len(filtered)
        }</span>

        <span class="cov0" title="0">return filtered[start:end], nil</span>
}

// FindByTag finds pipelines by tag
func (r *InMemoryPipelineRepository) FindByTag(ctx context.Context, tag string, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        filtered := make([]*entities.Pipeline, 0)
        for _, p := range r.pipelines </span><span class="cov0" title="0">{
                for _, t := range p.Tags </span><span class="cov0" title="0">{
                        if t == tag </span><span class="cov0" title="0">{
                                filtered = append(filtered, p)
                                break</span>
                        }
                }
        }

        // Apply pagination
        <span class="cov0" title="0">start := offset
        if start &gt; len(filtered) </span><span class="cov0" title="0">{
                return []*entities.Pipeline{}, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(filtered) </span><span class="cov0" title="0">{
                end = len(filtered)
        }</span>

        <span class="cov0" title="0">return filtered[start:end], nil</span>
}

// FindByStatus finds pipelines by status
func (r *InMemoryPipelineRepository) FindByStatus(ctx context.Context, status entities.PipelineStatus, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        filtered := make([]*entities.Pipeline, 0)
        for _, p := range r.pipelines </span><span class="cov0" title="0">{
                if p.Status == status </span><span class="cov0" title="0">{
                        filtered = append(filtered, p)
                }</span>
        }

        // Apply pagination
        <span class="cov0" title="0">start := offset
        if start &gt; len(filtered) </span><span class="cov0" title="0">{
                return []*entities.Pipeline{}, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(filtered) </span><span class="cov0" title="0">{
                end = len(filtered)
        }</span>

        <span class="cov0" title="0">return filtered[start:end], nil</span>
}

// Exists checks if a pipeline exists
func (r *InMemoryPipelineRepository) Exists(id entities.PipelineID) bool <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.pipelines[id]
        return exists
}</span>

// PostgreSQLPipelineRepository provides a PostgreSQL implementation of pipeline repository
type PostgreSQLPipelineRepository struct {
        db *sql.DB
}

// NewPostgreSQLPipelineRepository creates a new PostgreSQL pipeline repository
func NewPostgreSQLPipelineRepository(db *sql.DB) *PostgreSQLPipelineRepository <span class="cov0" title="0">{
        return &amp;PostgreSQLPipelineRepository{db: db}
}</span>

// Save saves a pipeline to the database
func (r *PostgreSQLPipelineRepository) Save(ctx context.Context, pipeline *entities.Pipeline) error <span class="cov0" title="0">{
        // Serialize steps and schedule as JSON
        stepsJSON, err := json.Marshal(pipeline.Steps)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to marshal steps")
        }</span>

        <span class="cov0" title="0">var scheduleJSON []byte
        if pipeline.Schedule != nil </span><span class="cov0" title="0">{
                scheduleJSON, err = json.Marshal(pipeline.Schedule)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to marshal schedule")
                }</span>
        }

        // Upsert pipeline
        <span class="cov0" title="0">query := `
                INSERT INTO pipelines (
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                ) VALUES (
                        $1, $2, $3, $4, $5, $6,
                        $7, $8, $9, $10,
                        $11, $12, $13
                )
                ON CONFLICT (id) DO UPDATE SET
                        name = EXCLUDED.name,
                        description = EXCLUDED.description,
                        status = EXCLUDED.status,
                        owner = EXCLUDED.owner,
                        tags = EXCLUDED.tags,
                        steps = EXCLUDED.steps,
                        schedule = EXCLUDED.schedule,
                        last_run_at = EXCLUDED.last_run_at,
                        next_run_at = EXCLUDED.next_run_at,
                        updated_at = EXCLUDED.updated_at,
                        version = EXCLUDED.version
        `

        _, err = r.db.ExecContext(ctx, query,
                pipeline.ID.String(),
                pipeline.Name,
                pipeline.Description,
                int(pipeline.Status),
                pipeline.Owner,
                pq.Array(pipeline.Tags),
                stepsJSON,
                scheduleJSON,
                pipeline.LastRunAt,
                pipeline.NextRunAt,
                pipeline.CreatedAt,
                pipeline.UpdatedAt,
                pipeline.Version,
        )

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to save pipeline")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FindByID finds a pipeline by ID
func (r *PostgreSQLPipelineRepository) FindByID(ctx context.Context, id entities.PipelineID) (*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                WHERE id = $1
        `

        row := r.db.QueryRowContext(ctx, query, id.String())
        return r.scanPipeline(row)
}</span>

// FindByName finds a pipeline by name
func (r *PostgreSQLPipelineRepository) FindByName(ctx context.Context, name string) (*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                WHERE name = $1
        `

        row := r.db.QueryRowContext(ctx, query, name)
        return r.scanPipeline(row)
}</span>

// Delete deletes a pipeline
func (r *PostgreSQLPipelineRepository) Delete(ctx context.Context, id entities.PipelineID) error <span class="cov0" title="0">{
        query := `DELETE FROM pipelines WHERE id = $1`
        
        result, err := r.db.ExecContext(ctx, query, id.String())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to delete pipeline")
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to get rows affected")
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.NotFoundError("pipeline")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// List lists pipelines with pagination
func (r *PostgreSQLPipelineRepository) List(ctx context.Context, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `

        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to list pipelines")
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanPipelines(rows)</span>
}

// Count counts total pipelines
func (r *PostgreSQLPipelineRepository) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM pipelines`
        
        var count int
        err := r.db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "failed to count pipelines")
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// FindByOwner finds pipelines by owner
func (r *PostgreSQLPipelineRepository) FindByOwner(ctx context.Context, owner string, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                WHERE owner = $1
                ORDER BY created_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, owner, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find pipelines by owner")
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanPipelines(rows)</span>
}

// FindByTag finds pipelines by tag
func (r *PostgreSQLPipelineRepository) FindByTag(ctx context.Context, tag string, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                WHERE $1 = ANY(tags)
                ORDER BY created_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, tag, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find pipelines by tag")
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanPipelines(rows)</span>
}

// FindByStatus finds pipelines by status
func (r *PostgreSQLPipelineRepository) FindByStatus(ctx context.Context, status entities.PipelineStatus, limit, offset int) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, name, description, status, owner, tags,
                        steps, schedule, last_run_at, next_run_at,
                        created_at, updated_at, version
                FROM pipelines
                WHERE status = $1
                ORDER BY created_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, int(status), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find pipelines by status")
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanPipelines(rows)</span>
}

// Exists checks if a pipeline exists
func (r *PostgreSQLPipelineRepository) Exists(id entities.PipelineID) bool <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM pipelines WHERE id = $1)`
        
        var exists bool
        err := r.db.QueryRow(query, id.String()).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return exists</span>
}

// scanPipeline scans a single pipeline from a row
func (r *PostgreSQLPipelineRepository) scanPipeline(row *sql.Row) (*entities.Pipeline, error) <span class="cov0" title="0">{
        var (
                idStr       string
                status      int
                stepsJSON   []byte
                scheduleJSON sql.NullString
                tags        pq.StringArray
                lastRunAt   sql.NullTime
                nextRunAt   sql.NullTime
        )

        pipeline := &amp;entities.Pipeline{}

        err := row.Scan(
                &amp;idStr,
                &amp;pipeline.Name,
                &amp;pipeline.Description,
                &amp;status,
                &amp;pipeline.Owner,
                &amp;tags,
                &amp;stepsJSON,
                &amp;scheduleJSON,
                &amp;lastRunAt,
                &amp;nextRunAt,
                &amp;pipeline.CreatedAt,
                &amp;pipeline.UpdatedAt,
                &amp;pipeline.Version,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to scan pipeline")
        }</span>

        // Convert ID
        <span class="cov0" title="0">pipeline.ID = entities.PipelineID(idStr)
        
        // Convert status
        pipeline.Status = entities.PipelineStatus(status)
        
        // Convert tags
        pipeline.Tags = []string(tags)
        
        // Unmarshal steps
        if err := json.Unmarshal(stepsJSON, &amp;pipeline.Steps); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to unmarshal steps")
        }</span>
        
        // Unmarshal schedule
        <span class="cov0" title="0">if scheduleJSON.Valid </span><span class="cov0" title="0">{
                var schedule entities.PipelineSchedule
                if err := json.Unmarshal([]byte(scheduleJSON.String), &amp;schedule); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal schedule")
                }</span>
                <span class="cov0" title="0">pipeline.Schedule = &amp;schedule</span>
        }
        
        // Set optional times
        <span class="cov0" title="0">if lastRunAt.Valid </span><span class="cov0" title="0">{
                pipeline.LastRunAt = &amp;lastRunAt.Time
        }</span>
        <span class="cov0" title="0">if nextRunAt.Valid </span><span class="cov0" title="0">{
                pipeline.NextRunAt = &amp;nextRunAt.Time
        }</span>

        <span class="cov0" title="0">return pipeline, nil</span>
}

// scanPipelines scans multiple pipelines from rows
func (r *PostgreSQLPipelineRepository) scanPipelines(rows *sql.Rows) ([]*entities.Pipeline, error) <span class="cov0" title="0">{
        pipelines := make([]*entities.Pipeline, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        idStr       string
                        status      int
                        stepsJSON   []byte
                        scheduleJSON sql.NullString
                        tags        pq.StringArray
                        lastRunAt   sql.NullTime
                        nextRunAt   sql.NullTime
                )

                pipeline := &amp;entities.Pipeline{}

                err := rows.Scan(
                        &amp;idStr,
                        &amp;pipeline.Name,
                        &amp;pipeline.Description,
                        &amp;status,
                        &amp;pipeline.Owner,
                        &amp;tags,
                        &amp;stepsJSON,
                        &amp;scheduleJSON,
                        &amp;lastRunAt,
                        &amp;nextRunAt,
                        &amp;pipeline.CreatedAt,
                        &amp;pipeline.UpdatedAt,
                        &amp;pipeline.Version,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to scan pipeline")
                }</span>

                // Convert fields (same as scanPipeline)
                <span class="cov0" title="0">pipeline.ID = entities.PipelineID(idStr)
                pipeline.Status = entities.PipelineStatus(status)
                pipeline.Tags = []string(tags)
                
                if err := json.Unmarshal(stepsJSON, &amp;pipeline.Steps); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal steps")
                }</span>
                
                <span class="cov0" title="0">if scheduleJSON.Valid </span><span class="cov0" title="0">{
                        var schedule entities.PipelineSchedule
                        if err := json.Unmarshal([]byte(scheduleJSON.String), &amp;schedule); err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "failed to unmarshal schedule")
                        }</span>
                        <span class="cov0" title="0">pipeline.Schedule = &amp;schedule</span>
                }
                
                <span class="cov0" title="0">if lastRunAt.Valid </span><span class="cov0" title="0">{
                        pipeline.LastRunAt = &amp;lastRunAt.Time
                }</span>
                <span class="cov0" title="0">if nextRunAt.Valid </span><span class="cov0" title="0">{
                        pipeline.NextRunAt = &amp;nextRunAt.Time
                }</span>

                <span class="cov0" title="0">pipelines = append(pipelines, pipeline)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error iterating rows")
        }</span>

        <span class="cov0" title="0">return pipelines, nil</span>
}

// CreateSchema creates the database schema
func CreateSchema(db *sql.DB) error <span class="cov0" title="0">{
        schema := `
                CREATE TABLE IF NOT EXISTS pipelines (
                        id VARCHAR(36) PRIMARY KEY,
                        name VARCHAR(255) NOT NULL UNIQUE,
                        description TEXT,
                        status INTEGER NOT NULL DEFAULT 0,
                        owner VARCHAR(255) NOT NULL,
                        tags TEXT[],
                        steps JSONB NOT NULL DEFAULT '[]',
                        schedule JSONB,
                        last_run_at TIMESTAMP,
                        next_run_at TIMESTAMP,
                        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        version BIGINT NOT NULL DEFAULT 1
                );

                CREATE INDEX IF NOT EXISTS idx_pipelines_name ON pipelines(name);
                CREATE INDEX IF NOT EXISTS idx_pipelines_owner ON pipelines(owner);
                CREATE INDEX IF NOT EXISTS idx_pipelines_status ON pipelines(status);
                CREATE INDEX IF NOT EXISTS idx_pipelines_tags ON pipelines USING GIN(tags);
                CREATE INDEX IF NOT EXISTS idx_pipelines_created_at ON pipelines(created_at);
        `

        _, err := db.Exec(schema)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create schema")
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">// Package domain contains the core business logic and domain models
package domain

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/google/uuid"
)

// DEPRECATED: Legacy imports will be removed in v2.0.0
// Use the new internal/domain structure instead
func init() <span class="cov1" title="1">{
        log.Println("WARNING: Using legacy FlexCore. Migrate to internal/domain structure.")
}</span>

// Event represents a domain event in the system
type Event struct {
        ID           string                 `json:"id"`
        Type         string                 `json:"type"`
        AggregateID  string                 `json:"aggregate_id"`
        Data         map[string]interface{} `json:"data"`
        Timestamp    time.Time              `json:"timestamp"`
        Version      int                    `json:"version"`
        Metadata     map[string]interface{} `json:"metadata"`
}

// NewEvent creates a new domain event
func NewEvent(eventType, aggregateID string, data map[string]interface{}) *Event <span class="cov3" title="2">{
        return &amp;Event{
                ID:          uuid.New().String(),
                Type:        eventType,
                AggregateID: aggregateID,
                Data:        data,
                Timestamp:   time.Now(),
                Version:     1,
                Metadata:    make(map[string]interface{}),
        }
}</span>

// Message represents a message in the distributed queue
type Message struct {
        ID        string                 `json:"id"`
        Queue     string                 `json:"queue"`
        Data      map[string]interface{} `json:"data"`
        CreatedAt time.Time              `json:"created_at"`
        Attempts  int                    `json:"attempts"`
        Status    string                 `json:"status"`
}

// NewMessage creates a new message
func NewMessage(queue string, data map[string]interface{}) *Message <span class="cov3" title="2">{
        return &amp;Message{
                ID:        uuid.New().String(),
                Queue:     queue,
                Data:      data,
                CreatedAt: time.Now(),
                Attempts:  0,
                Status:    "pending",
        }
}</span>

// FlexCoreConfig represents the core configuration
type FlexCoreConfig struct {
        WindmillURL       string `json:"windmill_url"`
        WindmillToken     string `json:"windmill_token"`
        WindmillWorkspace string `json:"windmill_workspace"`
        ClusterName       string `json:"cluster_name"`
        NodeID            string `json:"node_id"`
        ClusterNodes      []string `json:"cluster_nodes"`
        PluginDirectory   string `json:"plugin_directory"`
        MaxConcurrentJobs int    `json:"max_concurrent_jobs"`
        EventBufferSize   int    `json:"event_buffer_size"`
}

// DefaultConfig returns a default configuration
func DefaultConfig() *FlexCoreConfig <span class="cov6" title="7">{
        return &amp;FlexCoreConfig{
                WindmillURL:       "http://localhost:8000",
                WindmillWorkspace: "default",
                ClusterName:       "flexcore-cluster",
                NodeID:            "node-" + uuid.New().String()[:8],
                ClusterNodes:      []string{},
                PluginDirectory:   "./plugins",
                MaxConcurrentJobs: 100,
                EventBufferSize:   10000,
        }
}</span>

// Result represents a result that can either be a success or failure
type Result[T any] struct {
        value T
        err   error
}

// NewSuccess creates a successful result
func NewSuccess[T any](value T) *Result[T] <span class="cov10" title="20">{
        return &amp;Result[T]{value: value, err: nil}
}</span>

// NewFailure creates a failed result
func NewFailure[T any](err error) *Result[T] <span class="cov5" title="4">{
        var zero T
        return &amp;Result[T]{value: zero, err: err}
}</span>

// IsSuccess returns true if the result is successful
func (r *Result[T]) IsSuccess() bool <span class="cov9" title="19">{
        return r.err == nil
}</span>

// IsFailure returns true if the result is a failure
func (r *Result[T]) IsFailure() bool <span class="cov5" title="5">{
        return r.err != nil
}</span>

// Value returns the value if successful, panics if failure
func (r *Result[T]) Value() T <span class="cov8" title="12">{
        if r.err != nil </span><span class="cov1" title="1">{
                panic(fmt.Sprintf("Result is failure: %v", r.err))</span>
        }
        <span class="cov8" title="11">return r.value</span>
}

// Error returns the error if failure, nil if success
func (r *Result[T]) Error() error <span class="cov4" title="3">{
        return r.err
}</span>

// FlexCore represents the main distributed event processing engine
type FlexCore struct {
        config         *FlexCoreConfig
        eventQueue     chan *Event
        messageQueues  map[string]chan *Message
        plugins        map[string]interface{}
        workflows      map[string]interface{}
        customParams   map[string]interface{}
        
        mu             sync.RWMutex
        running        bool
        stopChan       chan struct{}
        waitGroup      sync.WaitGroup
}

// NewFlexCore creates a new FlexCore instance
func NewFlexCore(config *FlexCoreConfig) *Result[*FlexCore] <span class="cov6" title="7">{
        if config == nil </span><span class="cov1" title="1">{
                return NewFailure[*FlexCore](fmt.Errorf("config cannot be nil"))
        }</span>

        <span class="cov6" title="6">core := &amp;FlexCore{
                config:        config,
                eventQueue:    make(chan *Event, config.EventBufferSize),
                messageQueues: make(map[string]chan *Message),
                plugins:       make(map[string]interface{}),
                workflows:     make(map[string]interface{}),
                customParams:  make(map[string]interface{}),
                stopChan:      make(chan struct{}),
        }

        // Initialize custom parameters
        core.customParams["config"] = config
        core.customParams["node_id"] = config.NodeID

        return NewSuccess(core)</span>
}

// Start starts the FlexCore engine
func (fc *FlexCore) Start(ctx context.Context) *Result[bool] <span class="cov5" title="4">{
        fc.mu.Lock()
        defer fc.mu.Unlock()

        if fc.running </span><span class="cov1" title="1">{
                return NewFailure[bool](fmt.Errorf("FlexCore is already running"))
        }</span>

        <span class="cov4" title="3">fc.running = true
        
        // Start event processing
        fc.waitGroup.Add(1)
        go fc.processEvents(ctx)

        return NewSuccess(true)</span>
}

// Stop stops the FlexCore engine
func (fc *FlexCore) Stop(ctx context.Context) *Result[bool] <span class="cov5" title="4">{
        fc.mu.Lock()
        defer fc.mu.Unlock()

        if !fc.running </span><span class="cov1" title="1">{
                return NewSuccess(true)
        }</span>

        <span class="cov4" title="3">fc.running = false
        close(fc.stopChan)
        fc.waitGroup.Wait()

        return NewSuccess(true)</span>
}

// SendEvent sends an event to the system
func (fc *FlexCore) SendEvent(ctx context.Context, event *Event) *Result[bool] <span class="cov3" title="2">{
        if event == nil </span><span class="cov1" title="1">{
                return NewFailure[bool](fmt.Errorf("event cannot be nil"))
        }</span>

        <span class="cov1" title="1">select </span>{
        case fc.eventQueue &lt;- event:<span class="cov1" title="1">
                return NewSuccess(true)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return NewFailure[bool](ctx.Err())</span>
        default:<span class="cov0" title="0">
                return NewFailure[bool](fmt.Errorf("event queue is full"))</span>
        }
}

// SendMessage sends a message to a specific queue
func (fc *FlexCore) SendMessage(ctx context.Context, queue string, message *Message) *Result[bool] <span class="cov1" title="1">{
        if message == nil </span><span class="cov0" title="0">{
                return NewFailure[bool](fmt.Errorf("message cannot be nil"))
        }</span>

        <span class="cov1" title="1">fc.mu.Lock()
        queueChan, exists := fc.messageQueues[queue]
        if !exists </span><span class="cov1" title="1">{
                queueChan = make(chan *Message, 1000)
                fc.messageQueues[queue] = queueChan
        }</span>
        <span class="cov1" title="1">fc.mu.Unlock()

        select </span>{
        case queueChan &lt;- message:<span class="cov1" title="1">
                return NewSuccess(true)</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return NewFailure[bool](ctx.Err())</span>
        default:<span class="cov0" title="0">
                return NewFailure[bool](fmt.Errorf("queue %s is full", queue))</span>
        }
}

// ReceiveMessages receives messages from a queue
func (fc *FlexCore) ReceiveMessages(ctx context.Context, queue string, maxMessages int) *Result[[]*Message] <span class="cov1" title="1">{
        fc.mu.RLock()
        queueChan, exists := fc.messageQueues[queue]
        fc.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return NewSuccess([]*Message{})
        }</span>

        <span class="cov1" title="1">messages := make([]*Message, 0, maxMessages)
        for i := 0; i &lt; maxMessages; i++ </span><span class="cov7" title="10">{
                select </span>{
                case msg := &lt;-queueChan:<span class="cov1" title="1">
                        messages = append(messages, msg)</span>
                default:<span class="cov7" title="9">
                        // No more messages available
                        break</span>
                }
        }

        <span class="cov1" title="1">return NewSuccess(messages)</span>
}

// ExecuteWorkflow executes a workflow
func (fc *FlexCore) ExecuteWorkflow(ctx context.Context, path string, input map[string]interface{}) *Result[string] <span class="cov1" title="1">{
        jobID := uuid.New().String()
        
        // Simulate workflow execution
        fc.workflows[jobID] = map[string]interface{}{
                "path":       path,
                "input":      input,
                "status":     "running",
                "started_at": time.Now(),
        }

        return NewSuccess(jobID)
}</span>

// GetWorkflowStatus gets the status of a workflow
func (fc *FlexCore) GetWorkflowStatus(ctx context.Context, jobID string) *Result[map[string]interface{}] <span class="cov1" title="1">{
        fc.mu.RLock()
        workflow, exists := fc.workflows[jobID]
        fc.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return NewFailure[map[string]interface{}](fmt.Errorf("workflow %s not found", jobID))
        }</span>

        <span class="cov1" title="1">return NewSuccess(workflow.(map[string]interface{}))</span>
}

// GetClusterStatus returns the cluster status
func (fc *FlexCore) GetClusterStatus(ctx context.Context) *Result[map[string]interface{}] <span class="cov1" title="1">{
        status := map[string]interface{}{
                "cluster_name": fc.config.ClusterName,
                "node_id":      fc.config.NodeID,
                "cluster_size": len(fc.config.ClusterNodes) + 1, // +1 for this node
                "status":       "healthy",
                "uptime":       time.Since(time.Now()).String(), // Would track actual uptime
        }

        return NewSuccess(status)
}</span>

// GetCustomParameter gets a custom parameter
func (fc *FlexCore) GetCustomParameter(key string) interface{} <span class="cov0" title="0">{
        fc.mu.RLock()
        defer fc.mu.RUnlock()
        return fc.customParams[key]
}</span>

// SetCustomParameter sets a custom parameter
func (fc *FlexCore) SetCustomParameter(key string, value interface{}) <span class="cov0" title="0">{
        fc.mu.Lock()
        defer fc.mu.Unlock()
        fc.customParams[key] = value
}</span>

// processEvents processes events from the event queue
func (fc *FlexCore) processEvents(ctx context.Context) <span class="cov4" title="3">{
        defer fc.waitGroup.Done()

        for </span><span class="cov5" title="4">{
                select </span>{
                case event := &lt;-fc.eventQueue:<span class="cov1" title="1">
                        // Process event
                        log.Printf("Processing event: %s (Type: %s)", event.ID, event.Type)</span>
                        
                case &lt;-fc.stopChan:<span class="cov4" title="3">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}</pre>
		
		<pre class="file" id="file20" style="display: none">// Package adapter provides base functionality for all FlexCore adapters
package adapter

import (
        "context"
        "fmt"
        "time"

        "github.com/flext/flexcore/shared/result"
        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

// BaseAdapter provides common functionality for all adapters
type BaseAdapter struct {
        name      string
        version   string
        config    interface{}
        validator *validator.Validate
        tracer    trace.Tracer
        hooks     AdapterHooks
}

// AdapterHooks allows customization of adapter lifecycle
type AdapterHooks struct {
        OnBeforeExtract func(context.Context, ExtractRequest) error
        OnAfterExtract  func(context.Context, ExtractRequest, *ExtractResponse, error)
        OnBeforeLoad    func(context.Context, LoadRequest) error
        OnAfterLoad     func(context.Context, LoadRequest, *LoadResponse, error)
        OnError         func(context.Context, error)
}

// AdapterOption is a functional option for configuring adapters
type AdapterOption func(*BaseAdapter)

// WithHooks sets adapter hooks
func WithHooks(hooks AdapterHooks) AdapterOption <span class="cov0" title="0">{
        return func(a *BaseAdapter) </span><span class="cov0" title="0">{
                a.hooks = hooks
        }</span>
}

// WithValidator sets a custom validator
func WithValidator(v *validator.Validate) AdapterOption <span class="cov0" title="0">{
        return func(a *BaseAdapter) </span><span class="cov0" title="0">{
                a.validator = v
        }</span>
}

// NewBaseAdapter creates a new base adapter
func NewBaseAdapter(name, version string, opts ...AdapterOption) *BaseAdapter <span class="cov0" title="0">{
        adapter := &amp;BaseAdapter{
                name:      name,
                version:   version,
                validator: validator.New(),
                tracer:    otel.Tracer(name),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(adapter)
        }</span>

        <span class="cov0" title="0">return adapter</span>
}

// Name returns the adapter name
func (a *BaseAdapter) Name() string <span class="cov0" title="0">{
        return a.name
}</span>

// Version returns the adapter version
func (a *BaseAdapter) Version() string <span class="cov0" title="0">{
        return a.version
}</span>

// Configure configures the adapter with the provided configuration
func (a *BaseAdapter) Configure(configType interface{}, rawConfig map[string]interface{}) error <span class="cov0" title="0">{
        v := viper.New()
        v.SetConfigType("yaml")

        for k, val := range rawConfig </span><span class="cov0" title="0">{
                v.Set(k, val)
        }</span>

        <span class="cov0" title="0">if err := v.Unmarshal(configType); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := a.validator.Struct(configType); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">a.config = configType
        return nil</span>
}

// ExtractWithHooks wraps extraction with hooks and tracing
func (a *BaseAdapter) ExtractWithHooks(
        ctx context.Context,
        req ExtractRequest,
        extractFn func(context.Context, ExtractRequest) result.Result[*ExtractResponse],
) (*ExtractResponse, error) <span class="cov0" title="0">{
        ctx, span := a.tracer.Start(ctx, "Extract")
        defer span.End()

        // Before hook
        if a.hooks.OnBeforeExtract != nil </span><span class="cov0" title="0">{
                if err := a.hooks.OnBeforeExtract(ctx, req); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        return nil, err
                }</span>
        }

        // Execute extraction
        <span class="cov0" title="0">start := time.Now()
        result := extractFn(ctx, req)
        duration := time.Since(start)

        span.SetAttributes(
                attribute.String("adapter.name", a.name),
                attribute.String("adapter.version", a.version),
                attribute.Int64("duration.ms", duration.Milliseconds()),
        )

        var resp *ExtractResponse
        var err error

        if result.IsSuccess() </span><span class="cov0" title="0">{
                resp = result.Value()
                span.SetAttributes(
                        attribute.Int64("records.count", int64(len(resp.Records))),
                )
        }</span> else<span class="cov0" title="0"> {
                err = result.Error()
                span.RecordError(err)
                if a.hooks.OnError != nil </span><span class="cov0" title="0">{
                        a.hooks.OnError(ctx, err)
                }</span>
        }

        // After hook
        <span class="cov0" title="0">if a.hooks.OnAfterExtract != nil </span><span class="cov0" title="0">{
                a.hooks.OnAfterExtract(ctx, req, resp, err)
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

// LoadWithHooks wraps loading with hooks and tracing
func (a *BaseAdapter) LoadWithHooks(
        ctx context.Context,
        req LoadRequest,
        loadFn func(context.Context, LoadRequest) result.Result[*LoadResponse],
) (*LoadResponse, error) <span class="cov0" title="0">{
        ctx, span := a.tracer.Start(ctx, "Load")
        defer span.End()

        // Before hook
        if a.hooks.OnBeforeLoad != nil </span><span class="cov0" title="0">{
                if err := a.hooks.OnBeforeLoad(ctx, req); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        return nil, err
                }</span>
        }

        // Execute load
        <span class="cov0" title="0">start := time.Now()
        result := loadFn(ctx, req)
        duration := time.Since(start)

        span.SetAttributes(
                attribute.String("adapter.name", a.name),
                attribute.String("adapter.version", a.version),
                attribute.Int64("duration.ms", duration.Milliseconds()),
        )

        var resp *LoadResponse
        var err error

        if result.IsSuccess() </span><span class="cov0" title="0">{
                resp = result.Value()
                span.SetAttributes(
                        attribute.Int64("records.loaded", resp.RecordsLoaded),
                        attribute.Int64("records.failed", resp.RecordsFailed),
                )
        }</span> else<span class="cov0" title="0"> {
                err = result.Error()
                span.RecordError(err)
                if a.hooks.OnError != nil </span><span class="cov0" title="0">{
                        a.hooks.OnError(ctx, err)
                }</span>
        }

        // After hook
        <span class="cov0" title="0">if a.hooks.OnAfterLoad != nil </span><span class="cov0" title="0">{
                a.hooks.OnAfterLoad(ctx, req, resp, err)
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

// Config returns the typed configuration
func (a *BaseAdapter) Config() interface{} <span class="cov0" title="0">{
        return a.config
}</pre>
		
		<pre class="file" id="file21" style="display: none">// Package adapter provides builder pattern for creating adapters
package adapter

import (
        "context"
        "fmt"
        "time"

        "github.com/flext/flexcore/shared/result"
)

// AdapterBuilder provides a fluent interface for building adapters
type AdapterBuilder struct {
        name    string
        version string
        
        // Functions
        extractFn   ExtractFunc
        loadFn      LoadFunc
        transformFn TransformFunc
        healthFn    HealthCheckFunc
        configureFn ConfigureFunc
        
        // Options
        hooks      AdapterHooks
        middleware []Middleware
        
        // Validation
        validator func(interface{}) error
        
        // Error tracking
        err error
}

// Function types
type ExtractFunc func(context.Context, ExtractRequest) result.Result[*ExtractResponse]
type LoadFunc func(context.Context, LoadRequest) result.Result[*LoadResponse]
type TransformFunc func(context.Context, TransformRequest) result.Result[*TransformResponse]
type HealthCheckFunc func(context.Context) error
type ConfigureFunc func(map[string]interface{}) error

// Middleware for adapter operations
type Middleware func(Operation) Operation
type Operation func(context.Context, interface{}) (interface{}, error)

// NewAdapterBuilder creates a new adapter builder
func NewAdapterBuilder(name, version string) *AdapterBuilder <span class="cov0" title="0">{
        return &amp;AdapterBuilder{
                name:       name,
                version:    version,
                middleware: make([]Middleware, 0),
        }
}</span>

// WithExtract sets the extract function
func (b *AdapterBuilder) WithExtract(fn ExtractFunc) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.extractFn = fn
        return b</span>
}

// WithLoad sets the load function
func (b *AdapterBuilder) WithLoad(fn LoadFunc) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.loadFn = fn
        return b</span>
}

// WithTransform sets the transform function
func (b *AdapterBuilder) WithTransform(fn TransformFunc) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.transformFn = fn
        return b</span>
}

// WithHealthCheck sets the health check function
func (b *AdapterBuilder) WithHealthCheck(fn HealthCheckFunc) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.healthFn = fn
        return b</span>
}

// WithConfigure sets the configure function
func (b *AdapterBuilder) WithConfigure(fn ConfigureFunc) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.configureFn = fn
        return b</span>
}

// WithHooks sets adapter hooks
func (b *AdapterBuilder) WithHooks(hooks AdapterHooks) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.hooks = hooks
        return b</span>
}

// WithMiddleware adds middleware to the adapter
func (b *AdapterBuilder) WithMiddleware(mw ...Middleware) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.middleware = append(b.middleware, mw...)
        return b</span>
}

// WithValidator sets a validator function
func (b *AdapterBuilder) WithValidator(fn func(interface{}) error) *AdapterBuilder <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.validator = fn
        return b</span>
}

// Build creates the adapter
func (b *AdapterBuilder) Build() (Adapter, error) <span class="cov0" title="0">{
        if b.err != nil </span><span class="cov0" title="0">{
                return nil, b.err
        }</span>

        // Validate required functions
        <span class="cov0" title="0">if b.extractFn == nil &amp;&amp; b.loadFn == nil &amp;&amp; b.transformFn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("adapter must implement at least one operation (extract, load, or transform)")
        }</span>

        <span class="cov0" title="0">return &amp;builtAdapter{
                name:        b.name,
                version:     b.version,
                extractFn:   b.extractFn,
                loadFn:      b.loadFn,
                transformFn: b.transformFn,
                healthFn:    b.healthFn,
                configureFn: b.configureFn,
                hooks:       b.hooks,
                middleware:  b.middleware,
                validator:   b.validator,
        }, nil</span>
}

// builtAdapter is the adapter created by the builder
type builtAdapter struct {
        name    string
        version string
        
        extractFn   ExtractFunc
        loadFn      LoadFunc
        transformFn TransformFunc
        healthFn    HealthCheckFunc
        configureFn ConfigureFunc
        
        hooks      AdapterHooks
        middleware []Middleware
        validator  func(interface{}) error
        
        config interface{}
}

func (a *builtAdapter) Name() string <span class="cov0" title="0">{
        return a.name
}</span>

func (a *builtAdapter) Version() string <span class="cov0" title="0">{
        return a.version
}</span>

func (a *builtAdapter) Configure(config map[string]interface{}) error <span class="cov0" title="0">{
        if a.configureFn != nil </span><span class="cov0" title="0">{
                return a.configureFn(config)
        }</span>
        <span class="cov0" title="0">a.config = config
        return nil</span>
}

func (a *builtAdapter) Extract(ctx context.Context, req ExtractRequest) (*ExtractResponse, error) <span class="cov0" title="0">{
        if a.extractFn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extract not implemented")
        }</span>

        // Apply hooks
        <span class="cov0" title="0">if a.hooks.OnBeforeExtract != nil </span><span class="cov0" title="0">{
                if err := a.hooks.OnBeforeExtract(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Execute with middleware
        <span class="cov0" title="0">start := time.Now()
        result := a.extractFn(ctx, req)
        _ = time.Since(start)

        var resp *ExtractResponse
        var err error

        if result.IsSuccess() </span><span class="cov0" title="0">{
                resp = result.Value()
        }</span> else<span class="cov0" title="0"> {
                err = result.Error()
                if a.hooks.OnError != nil </span><span class="cov0" title="0">{
                        a.hooks.OnError(ctx, err)
                }</span>
        }

        // After hook
        <span class="cov0" title="0">if a.hooks.OnAfterExtract != nil </span><span class="cov0" title="0">{
                a.hooks.OnAfterExtract(ctx, req, resp, err)
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

func (a *builtAdapter) Load(ctx context.Context, req LoadRequest) (*LoadResponse, error) <span class="cov0" title="0">{
        if a.loadFn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load not implemented")
        }</span>

        // Apply hooks
        <span class="cov0" title="0">if a.hooks.OnBeforeLoad != nil </span><span class="cov0" title="0">{
                if err := a.hooks.OnBeforeLoad(ctx, req); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Execute
        <span class="cov0" title="0">result := a.loadFn(ctx, req)

        var resp *LoadResponse
        var err error

        if result.IsSuccess() </span><span class="cov0" title="0">{
                resp = result.Value()
        }</span> else<span class="cov0" title="0"> {
                err = result.Error()
                if a.hooks.OnError != nil </span><span class="cov0" title="0">{
                        a.hooks.OnError(ctx, err)
                }</span>
        }

        // After hook
        <span class="cov0" title="0">if a.hooks.OnAfterLoad != nil </span><span class="cov0" title="0">{
                a.hooks.OnAfterLoad(ctx, req, resp, err)
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}

func (a *builtAdapter) Transform(ctx context.Context, req TransformRequest) (*TransformResponse, error) <span class="cov0" title="0">{
        if a.transformFn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("transform not implemented")
        }</span>

        <span class="cov0" title="0">result := a.transformFn(ctx, req)
        if result.IsFailure() </span><span class="cov0" title="0">{
                return nil, result.Error()
        }</span>

        <span class="cov0" title="0">return result.Value(), nil</span>
}

func (a *builtAdapter) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        if a.healthFn == nil </span><span class="cov0" title="0">{
                return nil // Assume healthy if no health check provided
        }</span>
        <span class="cov0" title="0">return a.healthFn(ctx)</span>
}

// Common middleware implementations

// LoggingMiddleware logs all operations
func LoggingMiddleware(logger func(string, ...interface{})) Middleware <span class="cov0" title="0">{
        return func(next Operation) Operation </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        start := time.Now()
                        logger("Starting operation: %T", req)
                        
                        resp, err := next(ctx, req)
                        
                        duration := time.Since(start)
                        if err != nil </span><span class="cov0" title="0">{
                                logger("Operation failed after %v: %v", duration, err)
                        }</span> else<span class="cov0" title="0"> {
                                logger("Operation completed in %v", duration)
                        }</span>
                        
                        <span class="cov0" title="0">return resp, err</span>
                }
        }
}

// RetryMiddleware adds retry logic
func RetryMiddleware(maxRetries int, backoff time.Duration) Middleware <span class="cov0" title="0">{
        return func(next Operation) Operation </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        var lastErr error
                        
                        for i := 0; i &lt;= maxRetries; i++ </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return nil, ctx.Err()</span>
                                        case &lt;-time.After(backoff * time.Duration(i)):<span class="cov0" title="0"></span>
                                                // Continue with retry
                                        }
                                }
                                
                                <span class="cov0" title="0">resp, err := next(ctx, req)
                                if err == nil </span><span class="cov0" title="0">{
                                        return resp, nil
                                }</span>
                                
                                <span class="cov0" title="0">lastErr = err</span>
                        }
                        
                        <span class="cov0" title="0">return nil, fmt.Errorf("operation failed after %d retries: %w", maxRetries, lastErr)</span>
                }
        }
}

// TimeoutMiddleware adds timeout to operations
func TimeoutMiddleware(timeout time.Duration) Middleware <span class="cov0" title="0">{
        return func(next Operation) Operation </span><span class="cov0" title="0">{
                return func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(ctx, timeout)
                        defer cancel()
                        
                        return next(ctx, req)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file22" style="display: none">// Package patterns provides advanced Go patterns for FlexCore
package patterns

// Option represents an optional value
type Option[T any] struct {
        value   T
        present bool
}

// Some creates an Option with a value
func Some[T any](value T) Option[T] <span class="cov0" title="0">{
        return Option[T]{value: value, present: true}
}</span>

// None creates an empty Option
func None[T any]() Option[T] <span class="cov0" title="0">{
        var zero T
        return Option[T]{value: zero, present: false}
}</span>

// IsSome returns true if the Option contains a value
func (o Option[T]) IsSome() bool <span class="cov0" title="0">{
        return o.present
}</span>

// IsNone returns true if the Option is empty
func (o Option[T]) IsNone() bool <span class="cov0" title="0">{
        return !o.present
}</span>

// Unwrap returns the value, panics if None
func (o Option[T]) Unwrap() T <span class="cov0" title="0">{
        if !o.present </span><span class="cov0" title="0">{
                panic("called Unwrap on None value")</span>
        }
        <span class="cov0" title="0">return o.value</span>
}

// UnwrapOr returns the value or a default
func (o Option[T]) UnwrapOr(defaultValue T) T <span class="cov0" title="0">{
        if o.present </span><span class="cov0" title="0">{
                return o.value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// UnwrapOrElse returns the value or calls a function
func (o Option[T]) UnwrapOrElse(fn func() T) T <span class="cov0" title="0">{
        if o.present </span><span class="cov0" title="0">{
                return o.value
        }</span>
        <span class="cov0" title="0">return fn()</span>
}

// Map transforms the value if present
func MapOption[T, U any](o Option[T], fn func(T) U) Option[U] <span class="cov0" title="0">{
        if o.IsNone() </span><span class="cov0" title="0">{
                return None[U]()
        }</span>
        <span class="cov0" title="0">return Some(fn(o.value))</span>
}

// FlatMap transforms the value if present
func FlatMapOption[T, U any](o Option[T], fn func(T) Option[U]) Option[U] <span class="cov0" title="0">{
        if o.IsNone() </span><span class="cov0" title="0">{
                return None[U]()
        }</span>
        <span class="cov0" title="0">return fn(o.value)</span>
}

// Filter returns None if the predicate fails
func (o Option[T]) Filter(predicate func(T) bool) Option[T] <span class="cov0" title="0">{
        if o.IsNone() || !predicate(o.value) </span><span class="cov0" title="0">{
                return None[T]()
        }</span>
        <span class="cov0" title="0">return o</span>
}

// ForEach executes a function if the Option has a value
func (o Option[T]) ForEach(fn func(T)) <span class="cov0" title="0">{
        if o.IsSome() </span><span class="cov0" title="0">{
                fn(o.value)
        }</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">// Package patterns provides a SQL query builder pattern
package patterns

import (
        "fmt"
        "strings"
)

// QueryBuilder demonstrates the builder pattern for SQL queries
type QueryBuilder struct {
        table   string
        columns []string
        where   []WhereClause
        orderBy []OrderClause
        limit   int
        offset  int
        joins   []JoinClause
        groupBy []string
        having  []HavingClause
}

type WhereClause struct {
        Column   string
        Operator string
        Value    interface{}
}

type OrderClause struct {
        Column string
        Desc   bool
}

type JoinClause struct {
        Type      string // INNER, LEFT, RIGHT, FULL
        Table     string
        Condition string
}

type HavingClause struct {
        Condition string
        Value     interface{}
}

// NewQueryBuilder creates a new query builder
func NewQueryBuilder(table string) *QueryBuilder <span class="cov0" title="0">{
        return &amp;QueryBuilder{
                table:   table,
                columns: []string{"*"},
                where:   make([]WhereClause, 0),
                orderBy: make([]OrderClause, 0),
                joins:   make([]JoinClause, 0),
                groupBy: make([]string, 0),
                having:  make([]HavingClause, 0),
        }
}</span>

func (q *QueryBuilder) Select(columns ...string) *QueryBuilder <span class="cov0" title="0">{
        q.columns = columns
        return q
}</span>

func (q *QueryBuilder) Where(column, operator string, value interface{}) *QueryBuilder <span class="cov0" title="0">{
        q.where = append(q.where, WhereClause{column, operator, value})
        return q
}</span>

func (q *QueryBuilder) WhereIn(column string, values []interface{}) *QueryBuilder <span class="cov0" title="0">{
        q.where = append(q.where, WhereClause{column, "IN", values})
        return q
}</span>

func (q *QueryBuilder) OrderBy(column string, desc bool) *QueryBuilder <span class="cov0" title="0">{
        q.orderBy = append(q.orderBy, OrderClause{column, desc})
        return q
}</span>

func (q *QueryBuilder) Limit(limit int) *QueryBuilder <span class="cov0" title="0">{
        q.limit = limit
        return q
}</span>

func (q *QueryBuilder) Offset(offset int) *QueryBuilder <span class="cov0" title="0">{
        q.offset = offset
        return q
}</span>

func (q *QueryBuilder) Join(table, condition string) *QueryBuilder <span class="cov0" title="0">{
        q.joins = append(q.joins, JoinClause{"INNER", table, condition})
        return q
}</span>

func (q *QueryBuilder) LeftJoin(table, condition string) *QueryBuilder <span class="cov0" title="0">{
        q.joins = append(q.joins, JoinClause{"LEFT", table, condition})
        return q
}</span>

func (q *QueryBuilder) RightJoin(table, condition string) *QueryBuilder <span class="cov0" title="0">{
        q.joins = append(q.joins, JoinClause{"RIGHT", table, condition})
        return q
}</span>

func (q *QueryBuilder) GroupBy(columns ...string) *QueryBuilder <span class="cov0" title="0">{
        q.groupBy = append(q.groupBy, columns...)
        return q
}</span>

func (q *QueryBuilder) Having(condition string, value interface{}) *QueryBuilder <span class="cov0" title="0">{
        q.having = append(q.having, HavingClause{condition, value})
        return q
}</span>

func (q *QueryBuilder) Build() (string, []interface{}) <span class="cov0" title="0">{
        // Build SQL query
        query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(q.columns, ", "), q.table)
        
        var args []interface{}
        argIndex := 1
        
        // Add JOINs
        for _, join := range q.joins </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" %s JOIN %s ON %s", join.Type, join.Table, join.Condition)
        }</span>
        
        // Add WHERE clauses
        <span class="cov0" title="0">if len(q.where) &gt; 0 </span><span class="cov0" title="0">{
                whereClauses := make([]string, 0, len(q.where))
                for _, clause := range q.where </span><span class="cov0" title="0">{
                        if clause.Operator == "IN" </span><span class="cov0" title="0">{
                                values := clause.Value.([]interface{})
                                placeholders := make([]string, len(values))
                                for i, v := range values </span><span class="cov0" title="0">{
                                        placeholders[i] = fmt.Sprintf("$%d", argIndex)
                                        args = append(args, v)
                                        argIndex++
                                }</span>
                                <span class="cov0" title="0">whereClauses = append(whereClauses, fmt.Sprintf("%s IN (%s)", 
                                        clause.Column, strings.Join(placeholders, ", ")))</span>
                        } else<span class="cov0" title="0"> {
                                whereClauses = append(whereClauses, fmt.Sprintf("%s %s $%d", 
                                        clause.Column, clause.Operator, argIndex))
                                args = append(args, clause.Value)
                                argIndex++
                        }</span>
                }
                <span class="cov0" title="0">query += " WHERE " + strings.Join(whereClauses, " AND ")</span>
        }
        
        // Add GROUP BY
        <span class="cov0" title="0">if len(q.groupBy) &gt; 0 </span><span class="cov0" title="0">{
                query += " GROUP BY " + strings.Join(q.groupBy, ", ")
        }</span>
        
        // Add HAVING
        <span class="cov0" title="0">if len(q.having) &gt; 0 </span><span class="cov0" title="0">{
                havingClauses := make([]string, len(q.having))
                for i, clause := range q.having </span><span class="cov0" title="0">{
                        havingClauses[i] = fmt.Sprintf("%s $%d", clause.Condition, argIndex)
                        args = append(args, clause.Value)
                        argIndex++
                }</span>
                <span class="cov0" title="0">query += " HAVING " + strings.Join(havingClauses, " AND ")</span>
        }
        
        // Add ORDER BY
        <span class="cov0" title="0">if len(q.orderBy) &gt; 0 </span><span class="cov0" title="0">{
                orderClauses := make([]string, len(q.orderBy))
                for i, clause := range q.orderBy </span><span class="cov0" title="0">{
                        dir := "ASC"
                        if clause.Desc </span><span class="cov0" title="0">{
                                dir = "DESC"
                        }</span>
                        <span class="cov0" title="0">orderClauses[i] = fmt.Sprintf("%s %s", clause.Column, dir)</span>
                }
                <span class="cov0" title="0">query += " ORDER BY " + strings.Join(orderClauses, ", ")</span>
        }
        
        // Add LIMIT and OFFSET
        <span class="cov0" title="0">if q.limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT %d", q.limit)
        }</span>
        <span class="cov0" title="0">if q.offset &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" OFFSET %d", q.offset)
        }</span>
        
        <span class="cov0" title="0">return query, args</span>
}

// Clone creates a copy of the query builder
func (q *QueryBuilder) Clone() *QueryBuilder <span class="cov0" title="0">{
        clone := &amp;QueryBuilder{
                table:   q.table,
                columns: make([]string, len(q.columns)),
                where:   make([]WhereClause, len(q.where)),
                orderBy: make([]OrderClause, len(q.orderBy)),
                limit:   q.limit,
                offset:  q.offset,
                joins:   make([]JoinClause, len(q.joins)),
                groupBy: make([]string, len(q.groupBy)),
                having:  make([]HavingClause, len(q.having)),
        }
        
        copy(clone.columns, q.columns)
        copy(clone.where, q.where)
        copy(clone.orderBy, q.orderBy)
        copy(clone.joins, q.joins)
        copy(clone.groupBy, q.groupBy)
        copy(clone.having, q.having)
        
        return clone
}</pre>
		
		<pre class="file" id="file24" style="display: none">// Package patterns provides Railway-Oriented Programming for FlexCore
package patterns

import (
        "github.com/flext/flexcore/shared/errors"
        "github.com/flext/flexcore/shared/result"
)

// Railway represents a computation that can succeed or fail
type Railway[T any] struct {
        result result.Result[T]
}

// Track creates a new Railway from a Result
func Track[T any](r result.Result[T]) Railway[T] <span class="cov0" title="0">{
        return Railway[T]{result: r}
}</span>

// Success creates a successful Railway
func Success[T any](value T) Railway[T] <span class="cov0" title="0">{
        return Railway[T]{result: result.Success(value)}
}</span>

// Failure creates a failed Railway
func Failure[T any](err error) Railway[T] <span class="cov0" title="0">{
        return Railway[T]{result: result.Failure[T](err)}
}</span>

// Then chains operations on the success track
func (r Railway[T]) Then(fn func(T) error) Railway[T] <span class="cov0" title="0">{
        if r.result.IsFailure() </span><span class="cov0" title="0">{
                return r
        }</span>
        
        <span class="cov0" title="0">if err := fn(r.result.Value()); err != nil </span><span class="cov0" title="0">{
                return Failure[T](err)
        }</span>
        
        <span class="cov0" title="0">return r</span>
}

// Map transforms the value on the success track
func (r Railway[T]) Map(fn func(T) T) Railway[T] <span class="cov0" title="0">{
        if r.result.IsFailure() </span><span class="cov0" title="0">{
                return r
        }</span>
        
        <span class="cov0" title="0">return Success(fn(r.result.Value()))</span>
}

// FlatMap chains Railway operations
func (r Railway[T]) FlatMap(fn func(T) Railway[T]) Railway[T] <span class="cov0" title="0">{
        if r.result.IsFailure() </span><span class="cov0" title="0">{
                return r
        }</span>
        
        <span class="cov0" title="0">return fn(r.result.Value())</span>
}

// Recover handles errors and returns to success track
func (r Railway[T]) Recover(fn func(error) T) Railway[T] <span class="cov0" title="0">{
        if r.result.IsSuccess() </span><span class="cov0" title="0">{
                return r
        }</span>
        
        <span class="cov0" title="0">return Success(fn(r.result.Error()))</span>
}

// Result returns the underlying Result
func (r Railway[T]) Result() result.Result[T] <span class="cov0" title="0">{
        return r.result
}</span>

// Validate adds validation to the railway
func (r Railway[T]) Validate(predicate func(T) bool, errorMsg string) Railway[T] <span class="cov0" title="0">{
        if r.result.IsFailure() </span><span class="cov0" title="0">{
                return r
        }</span>
        
        <span class="cov0" title="0">if !predicate(r.result.Value()) </span><span class="cov0" title="0">{
                return Failure[T](errors.New(errorMsg))
        }</span>
        
        <span class="cov0" title="0">return r</span>
}

// Tap allows side effects without changing the value
func (r Railway[T]) Tap(fn func(T)) Railway[T] <span class="cov0" title="0">{
        if r.result.IsSuccess() </span><span class="cov0" title="0">{
                fn(r.result.Value())
        }</span>
        <span class="cov0" title="0">return r</span>
}

// TapError allows side effects on errors
func (r Railway[T]) TapError(fn func(error)) Railway[T] <span class="cov0" title="0">{
        if r.result.IsFailure() </span><span class="cov0" title="0">{
                fn(r.result.Error())
        }</span>
        <span class="cov0" title="0">return r</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">// Package errors provides error handling utilities for FlexCore
package errors

import (
        "fmt"
        "runtime"
        "strings"
)

// FlexError represents a FlexCore error with context
type FlexError struct {
        message   string
        cause     error
        code      string
        operation string
        file      string
        line      int
}

// Error implements the error interface
func (e *FlexError) Error() string <span class="cov0" title="0">{
        if e.cause != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.message, e.cause)
        }</span>
        <span class="cov0" title="0">return e.message</span>
}

// Unwrap returns the underlying error
func (e *FlexError) Unwrap() error <span class="cov0" title="0">{
        return e.cause
}</span>

// Code returns the error code
func (e *FlexError) Code() string <span class="cov0" title="0">{
        return e.code
}</span>

// Operation returns the operation that caused the error
func (e *FlexError) Operation() string <span class="cov0" title="0">{
        return e.operation
}</span>

// Location returns the file and line where the error occurred
func (e *FlexError) Location() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", e.file, e.line)
}</span>

// New creates a new FlexError
func New(message string) *FlexError <span class="cov0" title="0">{
        file, line := getCaller(2)
        return &amp;FlexError{
                message: message,
                file:    file,
                line:    line,
        }
}</span>

// Newf creates a new FlexError with formatted message
func Newf(format string, args ...interface{}) *FlexError <span class="cov0" title="0">{
        file, line := getCaller(2)
        return &amp;FlexError{
                message: fmt.Sprintf(format, args...),
                file:    file,
                line:    line,
        }
}</span>

// Wrap wraps an existing error with additional context
func Wrap(err error, message string) *FlexError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">file, line := getCaller(2)
        return &amp;FlexError{
                message: message,
                cause:   err,
                file:    file,
                line:    line,
        }</span>
}

// Wrapf wraps an existing error with formatted message
func Wrapf(err error, format string, args ...interface{}) *FlexError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">file, line := getCaller(2)
        return &amp;FlexError{
                message: fmt.Sprintf(format, args...),
                cause:   err,
                file:    file,
                line:    line,
        }</span>
}

// WithCode adds an error code
func (e *FlexError) WithCode(code string) *FlexError <span class="cov0" title="0">{
        e.code = code
        return e
}</span>

// WithOperation adds the operation context
func (e *FlexError) WithOperation(operation string) *FlexError <span class="cov0" title="0">{
        e.operation = operation
        return e
}</span>

// getCaller returns the file and line of the caller
func getCaller(skip int) (string, int) <span class="cov0" title="0">{
        _, file, line, ok := runtime.Caller(skip)
        if !ok </span><span class="cov0" title="0">{
                return "unknown", 0
        }</span>

        // Extract just the filename
        <span class="cov0" title="0">parts := strings.Split(file, "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                file = parts[len(parts)-1]
        }</span>

        <span class="cov0" title="0">return file, line</span>
}

// Common error codes
const (
        CodeValidation    = "VALIDATION_ERROR"
        CodeNotFound      = "NOT_FOUND"
        CodeAlreadyExists = "ALREADY_EXISTS"
        CodeUnauthorized  = "UNAUTHORIZED"
        CodeForbidden     = "FORBIDDEN"
        CodeInternal      = "INTERNAL_ERROR"
        CodeNetwork       = "NETWORK_ERROR"
        CodeTimeout       = "TIMEOUT_ERROR"
)

// Predefined error constructors
func ValidationError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeValidation)
}</span>

func NotFoundError(resource string) *FlexError <span class="cov0" title="0">{
        return Newf("%s not found", resource).WithCode(CodeNotFound)
}</span>

func AlreadyExistsError(resource string) *FlexError <span class="cov0" title="0">{
        return Newf("%s already exists", resource).WithCode(CodeAlreadyExists)
}</span>

func UnauthorizedError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeUnauthorized)
}</span>

func ForbiddenError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeForbidden)
}</span>

func InternalError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeInternal)
}</span>

func NetworkError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeNetwork)
}</span>

func TimeoutError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeTimeout)
}</span>

func SystemError(message string) *FlexError <span class="cov0" title="0">{
        return New(message).WithCode(CodeInternal)
}</pre>
		
		<pre class="file" id="file26" style="display: none">// Package patterns provides advanced functional patterns for FlexCore
package patterns

import (
        "time"
)

// Option represents a functional option pattern
type Option[T any] func(*T) error

// Apply applies all options to a target
func Apply[T any](target *T, opts ...Option[T]) error <span class="cov0" title="0">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(target); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Maybe represents an optional value
type Maybe[T any] struct {
        value   T
        present bool
}

// Some creates a Maybe with a value
func Some[T any](value T) Maybe[T] <span class="cov0" title="0">{
        return Maybe[T]{value: value, present: true}
}</span>

// None creates an empty Maybe
func None[T any]() Maybe[T] <span class="cov0" title="0">{
        var zero T
        return Maybe[T]{value: zero, present: false}
}</span>

// IsPresent returns true if the Maybe contains a value
func (m Maybe[T]) IsPresent() bool <span class="cov0" title="0">{
        return m.present
}</span>

// IsEmpty returns true if the Maybe is empty
func (m Maybe[T]) IsEmpty() bool <span class="cov0" title="0">{
        return !m.present
}</span>

// Get returns the value and a boolean indicating if it exists
func (m Maybe[T]) Get() (T, bool) <span class="cov0" title="0">{
        return m.value, m.present
}</span>

// OrElse returns the value if present, otherwise returns the default
func (m Maybe[T]) OrElse(defaultValue T) T <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                return m.value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// OrElseGet returns the value if present, otherwise calls the supplier
func (m Maybe[T]) OrElseGet(supplier func() T) T <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                return m.value
        }</span>
        <span class="cov0" title="0">return supplier()</span>
}

// Map transforms the value if present
func Map[T, U any](m Maybe[T], mapper func(T) U) Maybe[U] <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                return Some(mapper(m.value))
        }</span>
        <span class="cov0" title="0">return None[U]()</span>
}

// FlatMap transforms the value if present, flattening the result
func FlatMap[T, U any](m Maybe[T], mapper func(T) Maybe[U]) Maybe[U] <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                return mapper(m.value)
        }</span>
        <span class="cov0" title="0">return None[U]()</span>
}

// Filter returns the Maybe if the predicate is true, otherwise returns None
func (m Maybe[T]) Filter(predicate func(T) bool) Maybe[T] <span class="cov0" title="0">{
        if m.present &amp;&amp; predicate(m.value) </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov0" title="0">return None[T]()</span>
}

// IfPresent executes the consumer if a value is present
func (m Maybe[T]) IfPresent(consumer func(T)) <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                consumer(m.value)
        }</span>
}

// IfPresentOrElse executes the consumer if present, otherwise executes the empty action
func (m Maybe[T]) IfPresentOrElse(consumer func(T), emptyAction func()) <span class="cov0" title="0">{
        if m.present </span><span class="cov0" title="0">{
                consumer(m.value)
        }</span> else<span class="cov0" title="0"> {
                emptyAction()
        }</span>
}

// Railway represents a railway-oriented programming result
type Railway[T any] struct {
        value T
        err   error
}

// Success creates a successful Railway
func Success[T any](value T) Railway[T] <span class="cov0" title="0">{
        return Railway[T]{value: value}
}</span>

// Failure creates a failed Railway
func Failure[T any](err error) Railway[T] <span class="cov0" title="0">{
        var zero T
        return Railway[T]{value: zero, err: err}
}</span>

// IsSuccess returns true if the Railway is successful
func (r Railway[T]) IsSuccess() bool <span class="cov0" title="0">{
        return r.err == nil
}</span>

// IsFailure returns true if the Railway failed
func (r Railway[T]) IsFailure() bool <span class="cov0" title="0">{
        return r.err != nil
}</span>

// Value returns the value (may be zero if failed)
func (r Railway[T]) Value() T <span class="cov0" title="0">{
        return r.value
}</span>

// Error returns the error (nil if successful)
func (r Railway[T]) Error() error <span class="cov0" title="0">{
        return r.err
}</span>

// Then chains operations on the Railway
func Then[T, U any](r Railway[T], fn func(T) Railway[U]) Railway[U] <span class="cov0" title="0">{
        if r.IsFailure() </span><span class="cov0" title="0">{
                return Failure[U](r.err)
        }</span>
        <span class="cov0" title="0">return fn(r.value)</span>
}

// ThenMap transforms the value if successful
func ThenMap[T, U any](r Railway[T], fn func(T) U) Railway[U] <span class="cov0" title="0">{
        if r.IsFailure() </span><span class="cov0" title="0">{
                return Failure[U](r.err)
        }</span>
        <span class="cov0" title="0">return Success(fn(r.value))</span>
}

// Recover attempts to recover from an error
func (r Railway[T]) Recover(fn func(error) T) Railway[T] <span class="cov0" title="0">{
        if r.IsFailure() </span><span class="cov0" title="0">{
                return Success(fn(r.err))
        }</span>
        <span class="cov0" title="0">return r</span>
}

// RecoverWith attempts to recover with another Railway
func (r Railway[T]) RecoverWith(fn func(error) Railway[T]) Railway[T] <span class="cov0" title="0">{
        if r.IsFailure() </span><span class="cov0" title="0">{
                return fn(r.err)
        }</span>
        <span class="cov0" title="0">return r</span>
}

// Tap executes a side effect if successful
func (r Railway[T]) Tap(fn func(T)) Railway[T] <span class="cov0" title="0">{
        if r.IsSuccess() </span><span class="cov0" title="0">{
                fn(r.value)
        }</span>
        <span class="cov0" title="0">return r</span>
}

// TapError executes a side effect if failed
func (r Railway[T]) TapError(fn func(error)) Railway[T] <span class="cov0" title="0">{
        if r.IsFailure() </span><span class="cov0" title="0">{
                fn(r.err)
        }</span>
        <span class="cov0" title="0">return r</span>
}

// Retry represents a retry configuration
type Retry struct {
        MaxAttempts   int
        InitialDelay  time.Duration
        MaxDelay      time.Duration
        BackoffFactor float64
}

// DefaultRetry returns default retry configuration
func DefaultRetry() Retry <span class="cov0" title="0">{
        return Retry{
                MaxAttempts:   3,
                InitialDelay:  100 * time.Millisecond,
                MaxDelay:      5 * time.Second,
                BackoffFactor: 2.0,
        }
}</span>

// WithRetry executes a function with retry logic
func WithRetry[T any](retry Retry, fn func() Railway[T]) Railway[T] <span class="cov0" title="0">{
        var lastErr error
        delay := retry.InitialDelay

        for attempt := 0; attempt &lt; retry.MaxAttempts; attempt++ </span><span class="cov0" title="0">{
                result := fn()
                if result.IsSuccess() </span><span class="cov0" title="0">{
                        return result
                }</span>

                <span class="cov0" title="0">lastErr = result.err
                if attempt &lt; retry.MaxAttempts-1 </span><span class="cov0" title="0">{
                        time.Sleep(delay)
                        delay = time.Duration(float64(delay) * retry.BackoffFactor)
                        if delay &gt; retry.MaxDelay </span><span class="cov0" title="0">{
                                delay = retry.MaxDelay
                        }</span>
                }
        }

        <span class="cov0" title="0">return Failure[T](lastErr)</span>
}

// Lazy represents a lazy-evaluated value
type Lazy[T any] struct {
        fn       func() T
        value    T
        computed bool
}

// NewLazy creates a new lazy value
func NewLazy[T any](fn func() T) *Lazy[T] <span class="cov0" title="0">{
        return &amp;Lazy[T]{fn: fn}
}</span>

// Get returns the value, computing it if necessary
func (l *Lazy[T]) Get() T <span class="cov0" title="0">{
        if !l.computed </span><span class="cov0" title="0">{
                l.value = l.fn()
                l.computed = true
        }</span>
        <span class="cov0" title="0">return l.value</span>
}

// Reset clears the cached value
func (l *Lazy[T]) Reset() <span class="cov0" title="0">{
        l.computed = false
        var zero T
        l.value = zero
}</span>

// Either represents a value that can be one of two types
type Either[L, R any] struct {
        left  L
        right R
        isLeft bool
}

// Left creates a left Either
func Left[L, R any](value L) Either[L, R] <span class="cov0" title="0">{
        return Either[L, R]{left: value, isLeft: true}
}</span>

// Right creates a right Either
func Right[L, R any](value R) Either[L, R] <span class="cov0" title="0">{
        return Either[L, R]{right: value, isLeft: false}
}</span>

// IsLeft returns true if this is a left value
func (e Either[L, R]) IsLeft() bool <span class="cov0" title="0">{
        return e.isLeft
}</span>

// IsRight returns true if this is a right value
func (e Either[L, R]) IsRight() bool <span class="cov0" title="0">{
        return !e.isLeft
}</span>

// Left returns the left value
func (e Either[L, R]) Left() (L, bool) <span class="cov0" title="0">{
        return e.left, e.isLeft
}</span>

// Right returns the right value
func (e Either[L, R]) Right() (R, bool) <span class="cov0" title="0">{
        return e.right, !e.isLeft
}</span>

// Fold applies one of two functions based on the Either type
func Fold[L, R, T any](e Either[L, R], leftFn func(L) T, rightFn func(R) T) T <span class="cov0" title="0">{
        if e.isLeft </span><span class="cov0" title="0">{
                return leftFn(e.left)
        }</span>
        <span class="cov0" title="0">return rightFn(e.right)</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">// Package result provides a Result type for better error handling
package result

import (
        "github.com/flext/flexcore/shared/errors"
)

// Result represents either a success value or an error
type Result[T any] struct {
        value T
        err   error
}

// Success creates a successful result
func Success[T any](value T) Result[T] <span class="cov9" title="22">{
        return Result[T]{value: value}
}</span>

// Failure creates a failed result
func Failure[T any](err error) Result[T] <span class="cov9" title="24">{
        var zero T
        return Result[T]{value: zero, err: err}
}</span>

// FailureWithMessage creates a failed result with a message
func FailureWithMessage[T any](message string) Result[T] <span class="cov3" title="3">{
        return Failure[T](errors.New(message))
}</span>

// IsSuccess returns true if the result is successful
func (r Result[T]) IsSuccess() bool <span class="cov8" title="15">{
        return r.err == nil
}</span>

// IsFailure returns true if the result failed
func (r Result[T]) IsFailure() bool <span class="cov10" title="29">{
        return r.err != nil
}</span>

// Value returns the value if successful, or the zero value if failed
func (r Result[T]) Value() T <span class="cov7" title="10">{
        return r.value
}</span>

// Error returns the error if failed, or nil if successful
func (r Result[T]) Error() error <span class="cov8" title="14">{
        return r.err
}</span>

// ValueOr returns the value if successful, or the provided default if failed
func (r Result[T]) ValueOr(defaultValue T) T <span class="cov4" title="4">{
        if r.IsSuccess() </span><span class="cov2" title="2">{
                return r.value
        }</span>
        <span class="cov2" title="2">return defaultValue</span>
}

// ValueOrZero returns the value if successful, or the zero value if failed
func (r Result[T]) ValueOrZero() T <span class="cov2" title="2">{
        var zero T
        return r.ValueOr(zero)
}</span>

// Unwrap returns the value and error separately
func (r Result[T]) Unwrap() (T, error) <span class="cov2" title="2">{
        return r.value, r.err
}</span>

// UnwrapOrPanic returns the value or panics if there's an error
func (r Result[T]) UnwrapOrPanic() T <span class="cov2" title="2">{
        if r.err != nil </span><span class="cov1" title="1">{
                panic(r.err)</span>
        }
        <span class="cov1" title="1">return r.value</span>
}

// Map transforms the value if successful, or returns the error
func Map[T, U any](r Result[T], fn func(T) U) Result[U] <span class="cov2" title="2">{
        if r.IsFailure() </span><span class="cov1" title="1">{
                return Failure[U](r.err)
        }</span>
        <span class="cov1" title="1">return Success(fn(r.value))</span>
}

// FlatMap transforms the value if successful, or returns the error
func FlatMap[T, U any](r Result[T], fn func(T) Result[U]) Result[U] <span class="cov3" title="3">{
        if r.IsFailure() </span><span class="cov1" title="1">{
                return Failure[U](r.err)
        }</span>
        <span class="cov2" title="2">return fn(r.value)</span>
}

// Filter checks if the value satisfies a predicate
func (r Result[T]) Filter(predicate func(T) bool) Result[T] <span class="cov3" title="3">{
        if r.IsFailure() </span><span class="cov1" title="1">{
                return r
        }</span>
        <span class="cov2" title="2">if !predicate(r.value) </span><span class="cov1" title="1">{
                return FailureWithMessage[T]("filter predicate failed")
        }</span>
        <span class="cov1" title="1">return r</span>
}

// ForEach executes a function if the result is successful
func (r Result[T]) ForEach(fn func(T)) <span class="cov2" title="2">{
        if r.IsSuccess() </span><span class="cov1" title="1">{
                fn(r.value)
        }</span>
}

// IfFailure executes a function if the result failed
func (r Result[T]) IfFailure(fn func(error)) <span class="cov2" title="2">{
        if r.IsFailure() </span><span class="cov1" title="1">{
                fn(r.err)
        }</span>
}

// Combine two results into a tuple result
func Combine[T, U any](r1 Result[T], r2 Result[U]) Result[Tuple[T, U]] <span class="cov4" title="4">{
        if r1.IsFailure() </span><span class="cov2" title="2">{
                return Failure[Tuple[T, U]](r1.err)
        }</span>
        <span class="cov2" title="2">if r2.IsFailure() </span><span class="cov1" title="1">{
                return Failure[Tuple[T, U]](r2.err)
        }</span>
        <span class="cov1" title="1">return Success(Tuple[T, U]{First: r1.value, Second: r2.value})</span>
}

// Tuple represents a pair of values
type Tuple[T, U any] struct {
        First  T
        Second U
}

// Async represents an asynchronous result
type Async[T any] struct {
        ch chan Result[T]
}

// NewAsync creates a new async result
func NewAsync[T any]() *Async[T] <span class="cov4" title="4">{
        return &amp;Async[T]{
                ch: make(chan Result[T], 1),
        }
}</span>

// Complete completes the async result with a value
func (a *Async[T]) Complete(value T) <span class="cov2" title="2">{
        a.ch &lt;- Success(value)
        close(a.ch)
}</span>

// Fail completes the async result with an error
func (a *Async[T]) Fail(err error) <span class="cov2" title="2">{
        a.ch &lt;- Failure[T](err)
        close(a.ch)
}</span>

// Await waits for the async result to complete
func (a *Async[T]) Await() Result[T] <span class="cov4" title="4">{
        return &lt;-a.ch
}</span>

// Try executes a function that might panic and returns a result
func Try[T any](fn func() T) Result[T] <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                if r := recover(); r != nil </span>{<span class="cov0" title="0">
                        // This will be handled by the calling code
                }</span>
        }()

        <span class="cov1" title="1">value := fn()
        return Success(value)</span>
}

// TryAsync executes a function asynchronously that might panic
func TryAsync[T any](fn func() T) *Async[T] <span class="cov2" title="2">{
        async := NewAsync[T]()
        
        go func() </span><span class="cov2" title="2">{
                defer func() </span><span class="cov2" title="2">{
                        if r := recover(); r != nil </span><span class="cov1" title="1">{
                                async.Fail(errors.Newf("panic recovered: %v", r))
                        }</span>
                }()

                <span class="cov2" title="2">value := fn()
                async.Complete(value)</span>
        }()

        <span class="cov2" title="2">return async</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
