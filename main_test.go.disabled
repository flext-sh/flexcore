// Package flexcore integration tests
package flexcore_test

import (
	"context"
	"testing"
	"time"

	"github.com/flext/flexcore"
	"github.com/flext/flexcore/application/commands"
	"github.com/flext/flexcore/application/queries"
	"github.com/flext/flexcore/domain"
	"github.com/flext/flexcore/domain/entities"
	"github.com/flext/flexcore/infrastructure/di"
	"github.com/flext/flexcore/infrastructure/events"
	"github.com/flext/flexcore/infrastructure/persistence"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestFlexCoreIntegration(t *testing.T) {
	// Create kernel
	config := flexcore.NewKernelConfig()
	kernel := flexcore.NewKernel(config)

	// Bootstrap the kernel
	err := kernel.Bootstrap()
	require.NoError(t, err)

	// Get container
	container := kernel.Container()
	assert.NotNil(t, container)

	// Test that we can resolve key services
	eventBus := di.MustResolve[*events.EventBus](container)
	assert.NotNil(t, eventBus)

	commandBus := di.MustResolve[*commands.CommandBus](container)
	assert.NotNil(t, commandBus)

	// Create a pipeline using commands
	createCmd := commands.NewCreatePipelineCommand(
		"test-pipeline",
		"Test pipeline description",
		"test@example.com",
	)

	ctx := context.Background()
	createResult := commandBus.Handle(ctx, createCmd)
	require.True(t, createResult.IsSuccess())

	pipelineID := createResult.Value().(entities.PipelineID)
	assert.NotEmpty(t, pipelineID)

	// Query the pipeline
	queryBus := di.MustResolve[*queries.QueryBus](container)
	getQuery := queries.NewGetPipelineQuery(pipelineID)
	
	queryResult := queryBus.Handle(ctx, getQuery)
	require.True(t, queryResult.IsSuccess())

	pipeline := queryResult.Value().(*entities.Pipeline)
	assert.Equal(t, "test-pipeline", pipeline.Name)
	assert.Equal(t, "Test pipeline description", pipeline.Description)
	assert.Equal(t, "test@example.com", pipeline.Owner)

	// Shutdown
	err = kernel.Shutdown()
	assert.NoError(t, err)
}

func TestFlexCoreWithCustomContainer(t *testing.T) {
	// Create custom container
	container := di.NewContainer()
	
	// Register custom services
	container.RegisterSingleton(func() *persistence.InMemoryPipelineRepository {
		return persistence.NewInMemoryPipelineRepository()
	})

	// Create kernel with custom container
	config := &flexcore.KernelConfig{
		Container: container,
	}
	kernel := flexcore.NewKernel(config)

	// Bootstrap
	err := kernel.Bootstrap()
	require.NoError(t, err)

	// Verify custom service is available
	repo := di.MustResolve[*persistence.InMemoryPipelineRepository](container)
	assert.NotNil(t, repo)

	// Shutdown
	err = kernel.Shutdown()
	assert.NoError(t, err)
}

func TestCreateAndExecutePipeline(t *testing.T) {
	// Setup
	config := flexcore.NewKernelConfig()
	kernel := flexcore.NewKernel(config)
	err := kernel.Bootstrap()
	require.NoError(t, err)
	defer kernel.Shutdown()

	container := kernel.Container()
	commandBus := di.MustResolve[*commands.CommandBus](container)
	ctx := context.Background()

	// Create pipeline
	createCmd := commands.NewCreatePipelineCommand(
		"etl-pipeline",
		"ETL Pipeline for data processing",
		"admin@example.com",
	)

	createResult := commandBus.Handle(ctx, createCmd)
	require.True(t, createResult.IsSuccess())
	pipelineID := createResult.Value().(entities.PipelineID)

	// Add steps to pipeline
	step1 := entities.PipelineStep{
		ID:          "extract-step",
		Name:        "Extract Data",
		Type:        "extractor",
		Description: "Extract data from source",
		Config: map[string]interface{}{
			"source": "database",
			"table":  "users",
		},
		Order: 1,
	}

	addStepCmd := commands.NewAddStepCommand(pipelineID, step1)
	addStepResult := commandBus.Handle(ctx, addStepCmd)
	require.True(t, addStepResult.IsSuccess())

	// Execute pipeline
	executeCmd := commands.NewExecutePipelineCommand(pipelineID)
	executeResult := commandBus.Handle(ctx, executeCmd)
	
	// The execution might fail if no executor is registered, but command should succeed
	assert.NotNil(t, executeResult)
}

func TestEventHandling(t *testing.T) {
	// Setup
	config := flexcore.NewKernelConfig()
	kernel := flexcore.NewKernel(config)
	err := kernel.Bootstrap()
	require.NoError(t, err)
	defer kernel.Shutdown()

	container := kernel.Container()
	eventBus := di.MustResolve[*events.EventBus](container)
	commandBus := di.MustResolve[*commands.CommandBus](container)

	// Track events
	var receivedEvents []string
	eventBus.Subscribe("PipelineCreated", events.EventHandlerFunc(func(ctx context.Context, event domain.DomainEvent) error {
		receivedEvents = append(receivedEvents, event.EventType())
		return nil
	}))

	// Create pipeline (should raise PipelineCreated event)
	ctx := context.Background()
	createCmd := commands.NewCreatePipelineCommand(
		"event-test-pipeline",
		"Testing events",
		"events@example.com",
	)

	createResult := commandBus.Handle(ctx, createCmd)
	require.True(t, createResult.IsSuccess())

	// Give time for async event processing
	time.Sleep(100 * time.Millisecond)

	// Check events were received
	assert.Contains(t, receivedEvents, "PipelineCreated")
}

// Benchmarks

func BenchmarkPipelineCreation(b *testing.B) {
	config := flexcore.NewKernelConfig()
	kernel := flexcore.NewKernel(config)
	kernel.Bootstrap()
	defer kernel.Shutdown()

	container := kernel.Container()
	commandBus := di.MustResolve[*commands.CommandBus](container)
	ctx := context.Background()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		createCmd := commands.NewCreatePipelineCommand(
			"benchmark-pipeline",
			"Benchmark description",
			"bench@example.com",
		)
		_ = commandBus.Handle(ctx, createCmd)
	}
}